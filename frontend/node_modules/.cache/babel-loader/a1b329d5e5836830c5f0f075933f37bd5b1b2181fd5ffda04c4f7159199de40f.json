{"ast":null,"code":"import axios from 'axios';\nimport config from '../config/env';\nimport jwtDecode from 'jwt-decode';\n\n// Create axios instance with base URL from environment config\nconst api = axios.create({\n  baseURL: config.API_URL,\n  timeout: 15000,\n  // 15 seconds timeout\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// For health check endpoint, use a separate instance with shorter timeout\nexport const healthApi = axios.create({\n  baseURL: config.API_URL,\n  timeout: 5000\n});\n\n// Token cache to reduce localStorage access\nconst tokenCache = {\n  accessToken: null,\n  refreshToken: null,\n  lastUpdated: null,\n  // Get tokens with optional refresh from localStorage\n  getTokens(forceRefresh = false) {\n    // If we have tokens in cache and not forcing refresh, use them\n    if (!forceRefresh && this.accessToken && this.lastUpdated) {\n      // Only use cache if it's recent (5 seconds or less)\n      const cacheAge = Date.now() - this.lastUpdated;\n      if (cacheAge < 5000) {\n        return {\n          token: this.accessToken,\n          refreshToken: this.refreshToken\n        };\n      }\n    }\n\n    // Get from localStorage\n    const token = localStorage.getItem('token');\n    const refreshToken = localStorage.getItem('refresh_token');\n\n    // Update cache\n    this.accessToken = token;\n    this.refreshToken = refreshToken;\n    this.lastUpdated = Date.now();\n    return {\n      token,\n      refreshToken\n    };\n  },\n  // Set tokens in both cache and localStorage\n  setTokens(token, refreshToken) {\n    // Update localStorage\n    if (token) localStorage.setItem('token', token);\n    if (refreshToken) localStorage.setItem('refresh_token', refreshToken);\n\n    // Update cache\n    this.accessToken = token;\n    this.refreshToken = refreshToken;\n    this.lastUpdated = Date.now();\n  },\n  // Clear tokens from both cache and localStorage\n  clearTokens() {\n    localStorage.removeItem('token');\n    localStorage.removeItem('refresh_token');\n    this.accessToken = null;\n    this.refreshToken = null;\n    this.lastUpdated = null;\n  }\n};\n\n// Debug function to help troubleshoot token issues\nconst debugToken = token => {\n  if (!token) {\n    return {\n      hasToken: false\n    };\n  }\n  try {\n    // Try to extract data from the token (without verification)\n    const tokenParts = token.split('.');\n    if (tokenParts.length !== 3) {\n      return {\n        hasToken: true,\n        isValidFormat: false,\n        token: `${token.substring(0, 15)}...`\n      };\n    }\n\n    // Decode the payload (middle part)\n    const payload = JSON.parse(atob(tokenParts[1]));\n    const expiry = new Date(payload.exp * 1000).toLocaleString();\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    const isExpired = payload.exp < nowSeconds;\n    const expiresIn = isExpired ? 'Expired' : `${Math.floor((payload.exp - nowSeconds) / 60)} minutes`;\n    return {\n      hasToken: true,\n      isValidFormat: true,\n      token: `${token.substring(0, 15)}...`,\n      subject: payload.sub,\n      role: payload.role,\n      expiry,\n      isExpired,\n      expiresIn,\n      isRefreshToken: !!payload.refresh\n    };\n  } catch (error) {\n    return {\n      hasToken: true,\n      isValidFormat: false,\n      error: error.message\n    };\n  }\n};\n\n// Function to check if token needs refresh\nconst isTokenExpiringSoon = token => {\n  if (!token) return false;\n  try {\n    const payload = jwtDecode(token);\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    // Check if token will expire within the buffer time\n    return payload.exp - nowSeconds < config.TOKEN_EXPIRY_BUFFER;\n  } catch (error) {\n    return false;\n  }\n};\n\n// Track if a refresh is in progress to prevent multiple refreshes\nlet isRefreshingToken = false;\n// Store pending requests that are waiting for token refresh\nlet pendingRequests = [];\n\n// Function to refresh token\nconst refreshAuthToken = async () => {\n  try {\n    const {\n      refreshToken\n    } = tokenCache.getTokens(true);\n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n\n    // Use the refresh token for this request\n    const response = await api.post('/auth/refresh', {}, {\n      headers: {\n        'Authorization': `Bearer ${refreshToken}`\n      }\n    });\n    const {\n      access_token,\n      refresh_token\n    } = response.data;\n    if (access_token) {\n      storeAuthToken(access_token, refresh_token || refreshToken);\n      return true;\n    }\n    return false;\n  } catch (error) {\n    console.error('Failed to refresh token:', error);\n    clearAuthToken();\n    return false;\n  }\n};\n\n// Ensure the token is correctly set up for all requests\nconst setupTokenRefresh = () => {\n  const {\n    token\n  } = tokenCache.getTokens();\n  if (token) {\n    // Update both instances of axios\n    api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n\n    // Return token info for debugging\n    return debugToken(token);\n  } else {\n    delete api.defaults.headers.common['Authorization'];\n    return {\n      hasToken: false\n    };\n  }\n};\n\n// Function to store token in a consistent way\nconst storeAuthToken = (token, refreshToken) => {\n  // Store in cache and localStorage\n  tokenCache.setTokens(token, refreshToken);\n\n  // Set the token in axios defaults for all future requests\n  api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n};\n\n// Function to clear auth token completely\nconst clearAuthToken = () => {\n  tokenCache.clearTokens();\n  delete api.defaults.headers.common['Authorization'];\n};\n\n// Call this once at import time\nsetupTokenRefresh();\n\n// Add a request interceptor to include token with each request and handle token refresh\napi.interceptors.request.use(async config => {\n  // Get token from cache\n  const {\n    token\n  } = tokenCache.getTokens();\n  if (token) {\n    // Check if token is about to expire and needs refresh\n    if (isTokenExpiringSoon(token) && !config.url.includes('/auth/refresh')) {\n      try {\n        // Try to refresh the token\n        const newToken = await refreshAuthToken();\n        // Update the request with the new token\n        config.headers.Authorization = `Bearer ${newToken}`;\n      } catch (error) {\n        // If refresh fails but we still have the old token, use it anyway\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n    } else {\n      // Use the current token\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n  }\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\n\n// Add a response interceptor to handle 401 errors\napi.interceptors.response.use(response => {\n  return response;\n}, async error => {\n  // Get the original request configuration\n  const originalRequest = error.config;\n\n  // If we get a 401 error and haven't tried to refresh the token for this request yet\n  if (error.response && error.response.status === 401 && !originalRequest._retry) {\n    // Don't attempt refresh for auth endpoints to avoid infinite loops\n    if (originalRequest.url.includes('/auth/login') || originalRequest.url.includes('/auth/refresh')) {\n      // Just propagate the error for auth endpoints\n      clearAuthToken();\n      return Promise.reject(error);\n    }\n\n    // Mark this request as retried\n    originalRequest._retry = true;\n    try {\n      // Attempt to refresh the token\n      const newToken = await refreshAuthToken();\n\n      // Update the failed request with the new token\n      originalRequest.headers.Authorization = `Bearer ${newToken}`;\n\n      // Retry the original request with the new token\n      return api(originalRequest);\n    } catch (refreshError) {\n      // If refresh fails, clear tokens and redirect to login\n      clearAuthToken();\n\n      // Propagate the original error\n      return Promise.reject(error);\n    }\n  }\n\n  // For other errors, just propagate\n  return Promise.reject(error);\n});\n\n// Authentication\nconst login = async credentials => {\n  // Clear any existing token before login attempt\n  delete api.defaults.headers.common['Authorization'];\n  try {\n    // Ensure credentials match what the backend expects (username and password)\n    const {\n      email,\n      username,\n      password\n    } = credentials;\n    const payload = {\n      // If username is provided, use it, otherwise use email as username\n      username: username || email,\n      password\n    };\n\n    // Add better debugging\n    console.log('Login request payload:', {\n      username: payload.username,\n      hasPassword: !!payload.password,\n      url: `${api.defaults.baseURL}/auth/login`\n    });\n\n    // Make the request with longer timeout for debugging\n    const response = await api.post('/auth/login', payload, {\n      timeout: 10000 // 10 seconds timeout for debugging\n    });\n    console.log('Login API response status:', response.status);\n    console.log('Login API response headers:', response.headers);\n\n    // Check for tokens in response\n    const {\n      access_token,\n      token,\n      refresh_token\n    } = response.data;\n    const accessToken = access_token || token;\n    if (accessToken && refresh_token) {\n      storeAuthToken(accessToken, refresh_token);\n    } else {\n      console.warn('Missing tokens in login response:', {\n        hasAccessToken: !!accessToken,\n        hasRefreshToken: !!refresh_token\n      });\n    }\n    return response;\n  } catch (error) {\n    var _error$response, _error$response2, _error$response3, _error$response4;\n    console.error('Login error details:', {\n      message: error.message,\n      status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status,\n      statusText: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.statusText,\n      data: (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data,\n      headers: (_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.headers,\n      config: error.config\n    });\n    throw error;\n  }\n};\nconst register = async userData => {\n  // Clear any existing token before register attempt\n  delete api.defaults.headers.common['Authorization'];\n  try {\n    const response = await api.post('/auth/register', userData);\n    const {\n      token,\n      refresh_token\n    } = response.data;\n    if (token && refresh_token) {\n      storeAuthToken(token, refresh_token);\n    }\n    return response;\n  } catch (error) {\n    console.error('Registration error:', error);\n    throw error;\n  }\n};\nconst logout = async () => {\n  try {\n    // Call server-side logout if implemented\n    await api.post('/auth/logout');\n  } catch (error) {\n    // Ignore errors during logout\n    console.warn('Logout error (continuing anyway):', error);\n  } finally {\n    // Always clear local tokens\n    clearAuthToken();\n  }\n};\nconst getCurrentUser = () => {\n  setupTokenRefresh(); // Ensure token is set\n  return api.get('/users/me');\n};\n\n// User management\nconst getAllUsers = (params = {}) => {\n  return api.get('/users', {\n    params\n  });\n};\nconst getUserById = userId => {\n  return api.get(`/users/${userId}`);\n};\nconst updateUser = (userId, userData) => {\n  return api.put(`/users/${userId}`, userData);\n};\nconst deleteUser = userId => {\n  return api.delete(`/users/${userId}`);\n};\nconst createUser = userData => {\n  return api.post('/users', userData);\n};\n\n// Subscription management\nconst getAllSubscriptionPlans = () => {\n  return api.get('/subscriptions/plans');\n};\nconst getUserSubscription = () => {\n  return api.get('/subscriptions/me');\n};\nconst createSubscription = planId => {\n  return api.post('/subscriptions', {\n    plan_id: planId\n  });\n};\nconst cancelSubscription = reason => {\n  return api.delete('/subscriptions/me', {\n    data: {\n      reason\n    }\n  });\n};\nconst checkSubscription = () => {\n  return api.get('/subscriptions/check');\n};\n\n// Access code management\nconst generateAccessCode = () => {\n  return api.post('/access/generate');\n};\nconst getAccessCodes = () => {\n  return api.get('/access/me');\n};\nconst redeemAccessCode = accessCode => {\n  return api.post('/access/redeem', {\n    code: accessCode\n  });\n};\nconst revokeAccessCode = codeId => {\n  return api.post(`/access/revoke/${codeId}`);\n};\n\n// Admin functions\nconst getDashboardStats = () => {\n  return api.get('/admin/stats');\n};\nconst getAllSubscriptions = (params = {}) => {\n  return api.get('/admin/subscriptions', {\n    params\n  });\n};\nconst getUsersWithRoles = (params = {}) => {\n  return api.get('/admin/users', {\n    params\n  });\n};\nconst updateUserRole = (userId, role) => {\n  return api.put(`/admin/users/${userId}/role`, {\n    role\n  });\n};\n\n// Favorites\nconst getFavorites = () => {\n  return api.get('/favorites');\n};\nconst addToFavorites = (contentId, contentType) => {\n  return api.post('/favorites', {\n    content_id: contentId,\n    content_type: contentType\n  });\n};\nconst removeFromFavorites = contentId => {\n  return api.delete(`/favorites/${contentId}`);\n};\n\n// Watch history\nconst getWatchHistory = (params = {}) => {\n  return api.get('/history', {\n    params\n  });\n};\nconst addToWatchHistory = (contentId, watchDuration, watchPercentage) => {\n  return api.post('/history', {\n    content_id: contentId,\n    watch_duration: watchDuration,\n    watch_percentage: watchPercentage\n  });\n};\n\n// User profiles\nconst getUserProfiles = () => {\n  return api.get('/profile');\n};\nconst createProfile = profileData => {\n  return api.post('/profile', profileData);\n};\nconst updateProfile = (profileId, profileData) => {\n  return api.put(`/profile/${profileId}`, profileData);\n};\nconst deleteProfile = profileId => {\n  return api.delete(`/profile/${profileId}`);\n};\n\n// Password management\nconst updatePassword = (currentPassword, newPassword) => {\n  return api.post('/users/me/password', {\n    current_password: currentPassword,\n    new_password: newPassword\n  });\n};\nconst adminResetUserPassword = (userId, newPassword) => {\n  return api.post(`/admin/users/${userId}/reset-password`, {\n    new_password: newPassword\n  });\n};\nconst requestPasswordReset = async email => {\n  return api.post('/auth/forgot-password', {\n    email\n  });\n};\nconst resetPassword = async (token, newPassword) => {\n  return api.post('/auth/reset-password', {\n    token,\n    new_password: newPassword\n  });\n};\nexport { api as default, login, register, logout, getCurrentUser, getAllUsers, getUserById, updateUser, deleteUser, createUser, getAllSubscriptionPlans, getUserSubscription, createSubscription, cancelSubscription, checkSubscription, generateAccessCode, getAccessCodes, redeemAccessCode, revokeAccessCode, getDashboardStats, getAllSubscriptions, getUsersWithRoles, updateUserRole, getFavorites, addToFavorites, removeFromFavorites, getWatchHistory, addToWatchHistory, getUserProfiles, createProfile, updateProfile, deleteProfile, updatePassword, adminResetUserPassword, requestPasswordReset, resetPassword, debugToken, setupTokenRefresh, storeAuthToken, clearAuthToken, refreshAuthToken };","map":{"version":3,"names":["axios","config","jwtDecode","api","create","baseURL","API_URL","timeout","headers","healthApi","tokenCache","accessToken","refreshToken","lastUpdated","getTokens","forceRefresh","cacheAge","Date","now","token","localStorage","getItem","setTokens","setItem","clearTokens","removeItem","debugToken","hasToken","tokenParts","split","length","isValidFormat","substring","payload","JSON","parse","atob","expiry","exp","toLocaleString","nowSeconds","Math","floor","isExpired","expiresIn","subject","sub","role","isRefreshToken","refresh","error","message","isTokenExpiringSoon","TOKEN_EXPIRY_BUFFER","isRefreshingToken","pendingRequests","refreshAuthToken","Error","response","post","access_token","refresh_token","data","storeAuthToken","console","clearAuthToken","setupTokenRefresh","defaults","common","interceptors","request","use","url","includes","newToken","Authorization","Promise","reject","originalRequest","status","_retry","refreshError","login","credentials","email","username","password","log","hasPassword","warn","hasAccessToken","hasRefreshToken","_error$response","_error$response2","_error$response3","_error$response4","statusText","register","userData","logout","getCurrentUser","get","getAllUsers","params","getUserById","userId","updateUser","put","deleteUser","delete","createUser","getAllSubscriptionPlans","getUserSubscription","createSubscription","planId","plan_id","cancelSubscription","reason","checkSubscription","generateAccessCode","getAccessCodes","redeemAccessCode","accessCode","code","revokeAccessCode","codeId","getDashboardStats","getAllSubscriptions","getUsersWithRoles","updateUserRole","getFavorites","addToFavorites","contentId","contentType","content_id","content_type","removeFromFavorites","getWatchHistory","addToWatchHistory","watchDuration","watchPercentage","watch_duration","watch_percentage","getUserProfiles","createProfile","profileData","updateProfile","profileId","deleteProfile","updatePassword","currentPassword","newPassword","current_password","new_password","adminResetUserPassword","requestPasswordReset","resetPassword","default"],"sources":["D:/Movie/frontend/src/api/backendApi.js"],"sourcesContent":["import axios from 'axios';\nimport config from '../config/env';\nimport jwtDecode from 'jwt-decode';\n\n// Create axios instance with base URL from environment config\nconst api = axios.create({\n  baseURL: config.API_URL,\n  timeout: 15000, // 15 seconds timeout\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// For health check endpoint, use a separate instance with shorter timeout\nexport const healthApi = axios.create({\n  baseURL: config.API_URL,\n  timeout: 5000\n});\n\n// Token cache to reduce localStorage access\nconst tokenCache = {\n  accessToken: null,\n  refreshToken: null,\n  lastUpdated: null,\n  \n  // Get tokens with optional refresh from localStorage\n  getTokens(forceRefresh = false) {\n    // If we have tokens in cache and not forcing refresh, use them\n    if (!forceRefresh && this.accessToken && this.lastUpdated) {\n      // Only use cache if it's recent (5 seconds or less)\n      const cacheAge = Date.now() - this.lastUpdated;\n      if (cacheAge < 5000) {\n        return {\n          token: this.accessToken,\n          refreshToken: this.refreshToken\n        };\n      }\n    }\n    \n    // Get from localStorage\n    const token = localStorage.getItem('token');\n    const refreshToken = localStorage.getItem('refresh_token');\n    \n    // Update cache\n    this.accessToken = token;\n    this.refreshToken = refreshToken;\n    this.lastUpdated = Date.now();\n    \n    return { token, refreshToken };\n  },\n  \n  // Set tokens in both cache and localStorage\n  setTokens(token, refreshToken) {\n    // Update localStorage\n    if (token) localStorage.setItem('token', token);\n    if (refreshToken) localStorage.setItem('refresh_token', refreshToken);\n    \n    // Update cache\n    this.accessToken = token;\n    this.refreshToken = refreshToken;\n    this.lastUpdated = Date.now();\n  },\n  \n  // Clear tokens from both cache and localStorage\n  clearTokens() {\n    localStorage.removeItem('token');\n    localStorage.removeItem('refresh_token');\n    \n    this.accessToken = null;\n    this.refreshToken = null;\n    this.lastUpdated = null;\n  }\n};\n\n// Debug function to help troubleshoot token issues\nconst debugToken = (token) => {\n  if (!token) {\n    return { hasToken: false };\n  }\n\n  try {\n    // Try to extract data from the token (without verification)\n    const tokenParts = token.split('.');\n    if (tokenParts.length !== 3) {\n      return { hasToken: true, isValidFormat: false, token: `${token.substring(0, 15)}...` };\n    }\n\n    // Decode the payload (middle part)\n    const payload = JSON.parse(atob(tokenParts[1]));\n    const expiry = new Date(payload.exp * 1000).toLocaleString();\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    const isExpired = payload.exp < nowSeconds;\n    const expiresIn = isExpired \n      ? 'Expired' \n      : `${Math.floor((payload.exp - nowSeconds) / 60)} minutes`;\n\n    return {\n      hasToken: true,\n      isValidFormat: true,\n      token: `${token.substring(0, 15)}...`,\n      subject: payload.sub,\n      role: payload.role,\n      expiry,\n      isExpired,\n      expiresIn,\n      isRefreshToken: !!payload.refresh\n    };\n  } catch (error) {\n    return { hasToken: true, isValidFormat: false, error: error.message };\n  }\n};\n\n// Function to check if token needs refresh\nconst isTokenExpiringSoon = (token) => {\n  if (!token) return false;\n  \n  try {\n    const payload = jwtDecode(token);\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    // Check if token will expire within the buffer time\n    return payload.exp - nowSeconds < config.TOKEN_EXPIRY_BUFFER;\n  } catch (error) {\n    return false;\n  }\n};\n\n// Track if a refresh is in progress to prevent multiple refreshes\nlet isRefreshingToken = false;\n// Store pending requests that are waiting for token refresh\nlet pendingRequests = [];\n\n// Function to refresh token\nconst refreshAuthToken = async () => {\n  try {\n    const { refreshToken } = tokenCache.getTokens(true);\n    \n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n    \n    // Use the refresh token for this request\n    const response = await api.post('/auth/refresh', {}, {\n      headers: {\n        'Authorization': `Bearer ${refreshToken}`\n      }\n    });\n    \n    const { access_token, refresh_token } = response.data;\n    \n    if (access_token) {\n      storeAuthToken(access_token, refresh_token || refreshToken);\n      return true;\n    }\n    \n    return false;\n  } catch (error) {\n    console.error('Failed to refresh token:', error);\n    clearAuthToken();\n    return false;\n  }\n};\n\n// Ensure the token is correctly set up for all requests\nconst setupTokenRefresh = () => {\n  const { token } = tokenCache.getTokens();\n  if (token) {\n    // Update both instances of axios\n    api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    \n    // Return token info for debugging\n    return debugToken(token);\n  } else {\n    delete api.defaults.headers.common['Authorization'];\n    return { hasToken: false };\n  }\n};\n\n// Function to store token in a consistent way\nconst storeAuthToken = (token, refreshToken) => {\n  // Store in cache and localStorage\n  tokenCache.setTokens(token, refreshToken);\n  \n  // Set the token in axios defaults for all future requests\n  api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n};\n\n// Function to clear auth token completely\nconst clearAuthToken = () => {\n  tokenCache.clearTokens();\n  delete api.defaults.headers.common['Authorization'];\n};\n\n// Call this once at import time\nsetupTokenRefresh();\n\n// Add a request interceptor to include token with each request and handle token refresh\napi.interceptors.request.use(\n  async (config) => {\n    // Get token from cache\n    const { token } = tokenCache.getTokens();\n    \n    if (token) {\n      // Check if token is about to expire and needs refresh\n      if (isTokenExpiringSoon(token) && !config.url.includes('/auth/refresh')) {\n        try {\n          // Try to refresh the token\n          const newToken = await refreshAuthToken();\n          // Update the request with the new token\n          config.headers.Authorization = `Bearer ${newToken}`;\n        } catch (error) {\n          // If refresh fails but we still have the old token, use it anyway\n          config.headers.Authorization = `Bearer ${token}`;\n        }\n      } else {\n        // Use the current token\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n    }\n    \n    return config;\n  },\n  (error) => {\n    return Promise.reject(error);\n  }\n);\n\n// Add a response interceptor to handle 401 errors\napi.interceptors.response.use(\n  (response) => {\n    return response;\n  },\n  async (error) => {\n    // Get the original request configuration\n    const originalRequest = error.config;\n    \n    // If we get a 401 error and haven't tried to refresh the token for this request yet\n    if (error.response && error.response.status === 401 && !originalRequest._retry) {\n      // Don't attempt refresh for auth endpoints to avoid infinite loops\n      if (originalRequest.url.includes('/auth/login') || \n          originalRequest.url.includes('/auth/refresh')) {\n        // Just propagate the error for auth endpoints\n        clearAuthToken();\n        return Promise.reject(error);\n      }\n      \n      // Mark this request as retried\n      originalRequest._retry = true;\n      \n      try {\n        // Attempt to refresh the token\n        const newToken = await refreshAuthToken();\n        \n        // Update the failed request with the new token\n        originalRequest.headers.Authorization = `Bearer ${newToken}`;\n        \n        // Retry the original request with the new token\n        return api(originalRequest);\n      } catch (refreshError) {\n        // If refresh fails, clear tokens and redirect to login\n        clearAuthToken();\n        \n        // Propagate the original error\n        return Promise.reject(error);\n      }\n    }\n    \n    // For other errors, just propagate\n    return Promise.reject(error);\n  }\n);\n\n// Authentication\nconst login = async (credentials) => {\n  // Clear any existing token before login attempt\n  delete api.defaults.headers.common['Authorization'];\n  try {\n    // Ensure credentials match what the backend expects (username and password)\n    const { email, username, password } = credentials;\n    const payload = {\n      // If username is provided, use it, otherwise use email as username\n      username: username || email,\n      password\n    };\n    \n    // Add better debugging\n    console.log('Login request payload:', { \n      username: payload.username, \n      hasPassword: !!payload.password,\n      url: `${api.defaults.baseURL}/auth/login`\n    });\n    \n    // Make the request with longer timeout for debugging\n    const response = await api.post('/auth/login', payload, {\n      timeout: 10000 // 10 seconds timeout for debugging\n    });\n    \n    console.log('Login API response status:', response.status);\n    console.log('Login API response headers:', response.headers);\n    \n    // Check for tokens in response\n    const { access_token, token, refresh_token } = response.data;\n    const accessToken = access_token || token;\n    \n    if (accessToken && refresh_token) {\n      storeAuthToken(accessToken, refresh_token);\n    } else {\n      console.warn('Missing tokens in login response:', \n        { hasAccessToken: !!accessToken, hasRefreshToken: !!refresh_token });\n    }\n    \n    return response;\n  } catch (error) {\n    console.error('Login error details:', {\n      message: error.message,\n      status: error.response?.status,\n      statusText: error.response?.statusText,\n      data: error.response?.data,\n      headers: error.response?.headers,\n      config: error.config\n    });\n    throw error;\n  }\n};\n\nconst register = async (userData) => {\n  // Clear any existing token before register attempt\n  delete api.defaults.headers.common['Authorization'];\n  \n  try {\n    const response = await api.post('/auth/register', userData);\n    const { token, refresh_token } = response.data;\n    \n    if (token && refresh_token) {\n      storeAuthToken(token, refresh_token);\n    }\n    \n    return response;\n  } catch (error) {\n    console.error('Registration error:', error);\n    throw error;\n  }\n};\n\nconst logout = async () => {\n  try {\n    // Call server-side logout if implemented\n    await api.post('/auth/logout');\n  } catch (error) {\n    // Ignore errors during logout\n    console.warn('Logout error (continuing anyway):', error);\n  } finally {\n    // Always clear local tokens\n    clearAuthToken();\n  }\n};\n\nconst getCurrentUser = () => {\n  setupTokenRefresh(); // Ensure token is set\n  return api.get('/users/me');\n};\n\n// User management\nconst getAllUsers = (params = {}) => {\n  return api.get('/users', { params });\n};\n\nconst getUserById = (userId) => {\n  return api.get(`/users/${userId}`);\n};\n\nconst updateUser = (userId, userData) => {\n  return api.put(`/users/${userId}`, userData);\n};\n\nconst deleteUser = (userId) => {\n  return api.delete(`/users/${userId}`);\n};\n\nconst createUser = (userData) => {\n  return api.post('/users', userData);\n};\n\n// Subscription management\nconst getAllSubscriptionPlans = () => {\n  return api.get('/subscriptions/plans');\n};\n\nconst getUserSubscription = () => {\n  return api.get('/subscriptions/me');\n};\n\nconst createSubscription = (planId) => {\n  return api.post('/subscriptions', { plan_id: planId });\n};\n\nconst cancelSubscription = (reason) => {\n  return api.delete('/subscriptions/me', { \n    data: { reason } \n  });\n};\n\nconst checkSubscription = () => {\n  return api.get('/subscriptions/check');\n};\n\n// Access code management\nconst generateAccessCode = () => {\n  return api.post('/access/generate');\n};\n\nconst getAccessCodes = () => {\n  return api.get('/access/me');\n};\n\nconst redeemAccessCode = (accessCode) => {\n  return api.post('/access/redeem', { code: accessCode });\n};\n\nconst revokeAccessCode = (codeId) => {\n  return api.post(`/access/revoke/${codeId}`);\n};\n\n// Admin functions\nconst getDashboardStats = () => {\n  return api.get('/admin/stats');\n};\n\nconst getAllSubscriptions = (params = {}) => {\n  return api.get('/admin/subscriptions', { params });\n};\n\nconst getUsersWithRoles = (params = {}) => {\n  return api.get('/admin/users', { params });\n};\n\nconst updateUserRole = (userId, role) => {\n  return api.put(`/admin/users/${userId}/role`, { role });\n};\n\n// Favorites\nconst getFavorites = () => {\n  return api.get('/favorites');\n};\n\nconst addToFavorites = (contentId, contentType) => {\n  return api.post('/favorites', { content_id: contentId, content_type: contentType });\n};\n\nconst removeFromFavorites = (contentId) => {\n  return api.delete(`/favorites/${contentId}`);\n};\n\n// Watch history\nconst getWatchHistory = (params = {}) => {\n  return api.get('/history', { params });\n};\n\nconst addToWatchHistory = (contentId, watchDuration, watchPercentage) => {\n  return api.post('/history', { \n    content_id: contentId, \n    watch_duration: watchDuration, \n    watch_percentage: watchPercentage \n  });\n};\n\n// User profiles\nconst getUserProfiles = () => {\n  return api.get('/profile');\n};\n\nconst createProfile = (profileData) => {\n  return api.post('/profile', profileData);\n};\n\nconst updateProfile = (profileId, profileData) => {\n  return api.put(`/profile/${profileId}`, profileData);\n};\n\nconst deleteProfile = (profileId) => {\n  return api.delete(`/profile/${profileId}`);\n};\n\n// Password management\nconst updatePassword = (currentPassword, newPassword) => {\n  return api.post('/users/me/password', { current_password: currentPassword, new_password: newPassword });\n};\n\nconst adminResetUserPassword = (userId, newPassword) => {\n  return api.post(`/admin/users/${userId}/reset-password`, { new_password: newPassword });\n};\n\nconst requestPasswordReset = async (email) => {\n  return api.post('/auth/forgot-password', { email });\n};\n\nconst resetPassword = async (token, newPassword) => {\n  return api.post('/auth/reset-password', { \n    token, \n    new_password: newPassword\n  });\n};\n\nexport {\n  api as default,\n  login,\n  register,\n  logout,\n  getCurrentUser,\n  getAllUsers,\n  getUserById,\n  updateUser,\n  deleteUser,\n  createUser,\n  getAllSubscriptionPlans,\n  getUserSubscription,\n  createSubscription,\n  cancelSubscription,\n  checkSubscription,\n  generateAccessCode,\n  getAccessCodes,\n  redeemAccessCode,\n  revokeAccessCode,\n  getDashboardStats,\n  getAllSubscriptions,\n  getUsersWithRoles,\n  updateUserRole,\n  getFavorites,\n  addToFavorites,\n  removeFromFavorites,\n  getWatchHistory,\n  addToWatchHistory,\n  getUserProfiles,\n  createProfile,\n  updateProfile,\n  deleteProfile,\n  updatePassword,\n  adminResetUserPassword,\n  requestPasswordReset,\n  resetPassword,\n  debugToken,\n  setupTokenRefresh,\n  storeAuthToken,\n  clearAuthToken,\n  refreshAuthToken\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}