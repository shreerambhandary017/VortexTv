{"ast":null,"code":"import axios from 'axios';\nimport config from '../config/env';\nimport jwtDecode from 'jwt-decode';\n\n// Create axios instance with base URL from environment config\nconst api = axios.create({\n  baseURL: config.API_URL\n});\n\n// Debug function to help troubleshoot token issues\nconst debugToken = token => {\n  if (!token) {\n    return {\n      hasToken: false\n    };\n  }\n  try {\n    // Try to extract data from the token (without verification)\n    const tokenParts = token.split('.');\n    if (tokenParts.length !== 3) {\n      return {\n        hasToken: true,\n        isValidFormat: false,\n        token: `${token.substring(0, 15)}...`\n      };\n    }\n\n    // Decode the payload (middle part)\n    const payload = JSON.parse(atob(tokenParts[1]));\n    const expiry = new Date(payload.exp * 1000).toLocaleString();\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    const isExpired = payload.exp < nowSeconds;\n    const expiresIn = isExpired ? 'Expired' : `${Math.floor((payload.exp - nowSeconds) / 60)} minutes`;\n    return {\n      hasToken: true,\n      isValidFormat: true,\n      token: `${token.substring(0, 15)}...`,\n      subject: payload.sub,\n      role: payload.role,\n      expiry,\n      isExpired,\n      expiresIn,\n      isRefreshToken: !!payload.refresh\n    };\n  } catch (error) {\n    return {\n      hasToken: true,\n      isValidFormat: false,\n      error: error.message\n    };\n  }\n};\n\n// Function to check if token needs refresh\nconst isTokenExpiringSoon = token => {\n  if (!token) return false;\n  try {\n    const payload = jwtDecode(token);\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    // Check if token will expire within the buffer time\n    return payload.exp - nowSeconds < config.TOKEN_EXPIRY_BUFFER;\n  } catch (error) {\n    return false;\n  }\n};\n\n// Track if a refresh is in progress to prevent multiple refreshes\nlet isRefreshingToken = false;\n// Store pending requests that are waiting for token refresh\nlet pendingRequests = [];\n\n// Function to refresh token\nconst refreshAuthToken = async () => {\n  try {\n    const refreshToken = localStorage.getItem('refresh_token');\n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n\n    // Use the refresh token for this request\n    const response = await api.post('/auth/refresh', {}, {\n      headers: {\n        'Authorization': `Bearer ${refreshToken}`\n      }\n    });\n    const {\n      access_token,\n      refresh_token\n    } = response.data;\n    if (access_token) {\n      storeAuthToken(access_token, refresh_token || refreshToken);\n      return true;\n    }\n    return false;\n  } catch (error) {\n    console.error('Failed to refresh token:', error);\n    clearAuthToken();\n    return false;\n  }\n};\n\n// Ensure the token is correctly set up for all requests\nconst setupTokenRefresh = () => {\n  const token = localStorage.getItem('token');\n  if (token) {\n    // Update both instances of axios\n    api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n\n    // Return token info for debugging\n    return debugToken(token);\n  } else {\n    delete api.defaults.headers.common['Authorization'];\n    return {\n      hasToken: false\n    };\n  }\n};\n\n// Function to store token in a consistent way\nconst storeAuthToken = (token, refreshToken) => {\n  localStorage.setItem('token', token);\n  if (refreshToken) {\n    localStorage.setItem('refresh_token', refreshToken);\n  }\n\n  // Set the token in axios defaults for all future requests\n  api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n\n  // Set up automatic token refresh\n  setupTokenRefresh();\n};\n\n// Function to clear auth token completely\nconst clearAuthToken = () => {\n  localStorage.removeItem('token');\n  localStorage.removeItem('refresh_token');\n  delete api.defaults.headers.common['Authorization'];\n};\n\n// Call this once at import time\nsetupTokenRefresh();\n\n// Add a request interceptor to include token with each request and handle token refresh\napi.interceptors.request.use(async config => {\n  // Always get fresh token for each request\n  const token = localStorage.getItem('token');\n  if (token) {\n    // Check if token is about to expire and needs refresh\n    if (isTokenExpiringSoon(token) && !config.url.includes('/auth/refresh')) {\n      try {\n        // Try to refresh the token\n        const newToken = await refreshAuthToken();\n        // Update the request with the new token\n        config.headers.Authorization = `Bearer ${newToken}`;\n      } catch (error) {\n        // If refresh fails but we still have the old token, use it anyway\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n    } else {\n      // Use the current token\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n  }\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\n\n// Add a response interceptor to handle 401 errors\napi.interceptors.response.use(response => {\n  return response;\n}, async error => {\n  // Get the original request configuration\n  const originalRequest = error.config;\n\n  // If we get a 401 error and haven't tried to refresh the token for this request yet\n  if (error.response && error.response.status === 401 && !originalRequest._retry) {\n    // Don't attempt refresh for auth endpoints to avoid infinite loops\n    if (originalRequest.url.includes('/auth/login') || originalRequest.url.includes('/auth/refresh')) {\n      // Just propagate the error for auth endpoints\n      clearAuthToken();\n      return Promise.reject(error);\n    }\n\n    // Mark this request as retried\n    originalRequest._retry = true;\n    try {\n      // Attempt to refresh the token\n      const newToken = await refreshAuthToken();\n\n      // Update the failed request with the new token\n      originalRequest.headers.Authorization = `Bearer ${newToken}`;\n\n      // Retry the original request with the new token\n      return api(originalRequest);\n    } catch (refreshError) {\n      // If refresh fails, clear tokens and redirect to login\n      clearAuthToken();\n\n      // Propagate the original error\n      return Promise.reject(error);\n    }\n  }\n\n  // For other errors, just propagate\n  return Promise.reject(error);\n});\n\n// Authentication\nconst login = async credentials => {\n  // Clear any existing token before login attempt\n  delete api.defaults.headers.common['Authorization'];\n  try {\n    const response = await api.post('/auth/login', credentials);\n    const {\n      token,\n      refresh_token\n    } = response.data;\n    if (token && refresh_token) {\n      storeAuthToken(token, refresh_token);\n    }\n    return response;\n  } catch (error) {\n    console.error('Login error:', error);\n    throw error;\n  }\n};\nconst register = async userData => {\n  // Clear any existing token before register attempt\n  delete api.defaults.headers.common['Authorization'];\n  try {\n    const response = await api.post('/auth/register', userData);\n    const {\n      token,\n      refresh_token\n    } = response.data;\n    if (token && refresh_token) {\n      storeAuthToken(token, refresh_token);\n    }\n    return response;\n  } catch (error) {\n    console.error('Registration error:', error);\n    throw error;\n  }\n};\nconst logout = async () => {\n  try {\n    // Call server-side logout if implemented\n    await api.post('/auth/logout');\n  } catch (error) {\n    // Ignore errors during logout\n    console.warn('Logout error (continuing anyway):', error);\n  } finally {\n    // Always clear local tokens\n    clearAuthToken();\n  }\n};\nconst getCurrentUser = () => {\n  setupTokenRefresh(); // Ensure token is set\n  return api.get('/users/me');\n};\n\n// User management\nconst getAllUsers = (params = {}) => {\n  return api.get('/users', {\n    params\n  });\n};\nconst getUserById = userId => {\n  return api.get(`/users/${userId}`);\n};\nconst updateUser = (userId, userData) => {\n  return api.put(`/users/${userId}`, userData);\n};\nconst deleteUser = userId => {\n  return api.delete(`/users/${userId}`);\n};\nconst createUser = userData => {\n  return api.post('/users', userData);\n};\n\n// Subscription management\nconst getAllSubscriptionPlans = () => {\n  return api.get('/subscriptions/plans');\n};\nconst getUserSubscription = () => {\n  return api.get('/subscriptions/me');\n};\nconst createSubscription = planId => {\n  return api.post('/subscriptions', {\n    plan_id: planId\n  });\n};\nconst cancelSubscription = reason => {\n  return api.delete('/subscriptions/me', {\n    data: {\n      reason\n    }\n  });\n};\nconst checkSubscription = () => {\n  return api.get('/subscriptions/check');\n};\n\n// Access code management\nconst generateAccessCode = () => {\n  return api.post('/access/generate');\n};\nconst getAccessCodes = () => {\n  return api.get('/access/me');\n};\nconst redeemAccessCode = accessCode => {\n  return api.post('/access/redeem', {\n    code: accessCode\n  });\n};\nconst revokeAccessCode = codeId => {\n  return api.post(`/access/revoke/${codeId}`);\n};\n\n// Admin functions\nconst getDashboardStats = () => {\n  return api.get('/admin/stats');\n};\nconst getAllSubscriptions = (params = {}) => {\n  return api.get('/admin/subscriptions', {\n    params\n  });\n};\nconst getUsersWithRoles = (params = {}) => {\n  return api.get('/admin/users', {\n    params\n  });\n};\nconst updateUserRole = (userId, role) => {\n  return api.put(`/admin/users/${userId}/role`, {\n    role\n  });\n};\n\n// Favorites\nconst getFavorites = () => {\n  return api.get('/favorites');\n};\nconst addToFavorites = (contentId, contentType) => {\n  return api.post('/favorites', {\n    content_id: contentId,\n    content_type: contentType\n  });\n};\nconst removeFromFavorites = contentId => {\n  return api.delete(`/favorites/${contentId}`);\n};\n\n// Watch history\nconst getWatchHistory = (params = {}) => {\n  return api.get('/history', {\n    params\n  });\n};\nconst addToWatchHistory = (contentId, watchDuration, watchPercentage) => {\n  return api.post('/history', {\n    content_id: contentId,\n    watch_duration: watchDuration,\n    watch_percentage: watchPercentage\n  });\n};\n\n// User profiles\nconst getUserProfiles = () => {\n  return api.get('/profile');\n};\nconst createProfile = profileData => {\n  return api.post('/profile', profileData);\n};\nconst updateProfile = (profileId, profileData) => {\n  return api.put(`/profile/${profileId}`, profileData);\n};\nconst deleteProfile = profileId => {\n  return api.delete(`/profile/${profileId}`);\n};\n\n// Password management\nconst updatePassword = (currentPassword, newPassword) => {\n  return api.post('/users/me/password', {\n    current_password: currentPassword,\n    new_password: newPassword\n  });\n};\nconst adminResetUserPassword = (userId, newPassword) => {\n  return api.post(`/admin/users/${userId}/reset-password`, {\n    new_password: newPassword\n  });\n};\nconst requestPasswordReset = async email => {\n  return api.post('/auth/forgot-password', {\n    email\n  });\n};\nconst resetPassword = async (token, newPassword) => {\n  return api.post('/auth/reset-password', {\n    token,\n    new_password: newPassword\n  });\n};\nexport { api as default, login, register, logout, getCurrentUser, getAllUsers, getUserById, updateUser, deleteUser, createUser, getAllSubscriptionPlans, getUserSubscription, createSubscription, cancelSubscription, checkSubscription, generateAccessCode, getAccessCodes, redeemAccessCode, revokeAccessCode, getDashboardStats, getAllSubscriptions, getUsersWithRoles, updateUserRole, getFavorites, addToFavorites, removeFromFavorites, getWatchHistory, addToWatchHistory, getUserProfiles, createProfile, updateProfile, deleteProfile, updatePassword, adminResetUserPassword, requestPasswordReset, resetPassword, debugToken, setupTokenRefresh, storeAuthToken, clearAuthToken, refreshAuthToken };","map":{"version":3,"names":["axios","config","jwtDecode","api","create","baseURL","API_URL","debugToken","token","hasToken","tokenParts","split","length","isValidFormat","substring","payload","JSON","parse","atob","expiry","Date","exp","toLocaleString","nowSeconds","Math","floor","now","isExpired","expiresIn","subject","sub","role","isRefreshToken","refresh","error","message","isTokenExpiringSoon","TOKEN_EXPIRY_BUFFER","isRefreshingToken","pendingRequests","refreshAuthToken","refreshToken","localStorage","getItem","Error","response","post","headers","access_token","refresh_token","data","storeAuthToken","console","clearAuthToken","setupTokenRefresh","defaults","common","setItem","removeItem","interceptors","request","use","url","includes","newToken","Authorization","Promise","reject","originalRequest","status","_retry","refreshError","login","credentials","register","userData","logout","warn","getCurrentUser","get","getAllUsers","params","getUserById","userId","updateUser","put","deleteUser","delete","createUser","getAllSubscriptionPlans","getUserSubscription","createSubscription","planId","plan_id","cancelSubscription","reason","checkSubscription","generateAccessCode","getAccessCodes","redeemAccessCode","accessCode","code","revokeAccessCode","codeId","getDashboardStats","getAllSubscriptions","getUsersWithRoles","updateUserRole","getFavorites","addToFavorites","contentId","contentType","content_id","content_type","removeFromFavorites","getWatchHistory","addToWatchHistory","watchDuration","watchPercentage","watch_duration","watch_percentage","getUserProfiles","createProfile","profileData","updateProfile","profileId","deleteProfile","updatePassword","currentPassword","newPassword","current_password","new_password","adminResetUserPassword","requestPasswordReset","email","resetPassword","default"],"sources":["D:/Movie/frontend/src/api/backendApi.js"],"sourcesContent":["import axios from 'axios';\nimport config from '../config/env';\nimport jwtDecode from 'jwt-decode';\n\n// Create axios instance with base URL from environment config\nconst api = axios.create({\n  baseURL: config.API_URL\n});\n\n// Debug function to help troubleshoot token issues\nconst debugToken = (token) => {\n  if (!token) {\n    return { hasToken: false };\n  }\n\n  try {\n    // Try to extract data from the token (without verification)\n    const tokenParts = token.split('.');\n    if (tokenParts.length !== 3) {\n      return { hasToken: true, isValidFormat: false, token: `${token.substring(0, 15)}...` };\n    }\n\n    // Decode the payload (middle part)\n    const payload = JSON.parse(atob(tokenParts[1]));\n    const expiry = new Date(payload.exp * 1000).toLocaleString();\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    const isExpired = payload.exp < nowSeconds;\n    const expiresIn = isExpired \n      ? 'Expired' \n      : `${Math.floor((payload.exp - nowSeconds) / 60)} minutes`;\n\n    return {\n      hasToken: true,\n      isValidFormat: true,\n      token: `${token.substring(0, 15)}...`,\n      subject: payload.sub,\n      role: payload.role,\n      expiry,\n      isExpired,\n      expiresIn,\n      isRefreshToken: !!payload.refresh\n    };\n  } catch (error) {\n    return { hasToken: true, isValidFormat: false, error: error.message };\n  }\n};\n\n// Function to check if token needs refresh\nconst isTokenExpiringSoon = (token) => {\n  if (!token) return false;\n  \n  try {\n    const payload = jwtDecode(token);\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    // Check if token will expire within the buffer time\n    return payload.exp - nowSeconds < config.TOKEN_EXPIRY_BUFFER;\n  } catch (error) {\n    return false;\n  }\n};\n\n// Track if a refresh is in progress to prevent multiple refreshes\nlet isRefreshingToken = false;\n// Store pending requests that are waiting for token refresh\nlet pendingRequests = [];\n\n// Function to refresh token\nconst refreshAuthToken = async () => {\n  try {\n    const refreshToken = localStorage.getItem('refresh_token');\n    \n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n    \n    // Use the refresh token for this request\n    const response = await api.post('/auth/refresh', {}, {\n      headers: {\n        'Authorization': `Bearer ${refreshToken}`\n      }\n    });\n    \n    const { access_token, refresh_token } = response.data;\n    \n    if (access_token) {\n      storeAuthToken(access_token, refresh_token || refreshToken);\n      return true;\n    }\n    \n    return false;\n  } catch (error) {\n    console.error('Failed to refresh token:', error);\n    clearAuthToken();\n    return false;\n  }\n};\n\n// Ensure the token is correctly set up for all requests\nconst setupTokenRefresh = () => {\n  const token = localStorage.getItem('token');\n  if (token) {\n    // Update both instances of axios\n    api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    \n    // Return token info for debugging\n    return debugToken(token);\n  } else {\n    delete api.defaults.headers.common['Authorization'];\n    return { hasToken: false };\n  }\n};\n\n// Function to store token in a consistent way\nconst storeAuthToken = (token, refreshToken) => {\n  localStorage.setItem('token', token);\n  if (refreshToken) {\n    localStorage.setItem('refresh_token', refreshToken);\n  }\n  \n  // Set the token in axios defaults for all future requests\n  api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n  \n  // Set up automatic token refresh\n  setupTokenRefresh();\n};\n\n// Function to clear auth token completely\nconst clearAuthToken = () => {\n  localStorage.removeItem('token');\n  localStorage.removeItem('refresh_token');\n  delete api.defaults.headers.common['Authorization'];\n};\n\n// Call this once at import time\nsetupTokenRefresh();\n\n// Add a request interceptor to include token with each request and handle token refresh\napi.interceptors.request.use(\n  async (config) => {\n    // Always get fresh token for each request\n    const token = localStorage.getItem('token');\n    \n    if (token) {\n      // Check if token is about to expire and needs refresh\n      if (isTokenExpiringSoon(token) && !config.url.includes('/auth/refresh')) {\n        try {\n          // Try to refresh the token\n          const newToken = await refreshAuthToken();\n          // Update the request with the new token\n          config.headers.Authorization = `Bearer ${newToken}`;\n        } catch (error) {\n          // If refresh fails but we still have the old token, use it anyway\n          config.headers.Authorization = `Bearer ${token}`;\n        }\n      } else {\n        // Use the current token\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n    }\n    \n    return config;\n  },\n  (error) => {\n    return Promise.reject(error);\n  }\n);\n\n// Add a response interceptor to handle 401 errors\napi.interceptors.response.use(\n  (response) => {\n    return response;\n  },\n  async (error) => {\n    // Get the original request configuration\n    const originalRequest = error.config;\n    \n    // If we get a 401 error and haven't tried to refresh the token for this request yet\n    if (error.response && error.response.status === 401 && !originalRequest._retry) {\n      // Don't attempt refresh for auth endpoints to avoid infinite loops\n      if (originalRequest.url.includes('/auth/login') || \n          originalRequest.url.includes('/auth/refresh')) {\n        // Just propagate the error for auth endpoints\n        clearAuthToken();\n        return Promise.reject(error);\n      }\n      \n      // Mark this request as retried\n      originalRequest._retry = true;\n      \n      try {\n        // Attempt to refresh the token\n        const newToken = await refreshAuthToken();\n        \n        // Update the failed request with the new token\n        originalRequest.headers.Authorization = `Bearer ${newToken}`;\n        \n        // Retry the original request with the new token\n        return api(originalRequest);\n      } catch (refreshError) {\n        // If refresh fails, clear tokens and redirect to login\n        clearAuthToken();\n        \n        // Propagate the original error\n        return Promise.reject(error);\n      }\n    }\n    \n    // For other errors, just propagate\n    return Promise.reject(error);\n  }\n);\n\n// Authentication\nconst login = async (credentials) => {\n  // Clear any existing token before login attempt\n  delete api.defaults.headers.common['Authorization'];\n  try {\n    const response = await api.post('/auth/login', credentials);\n    const { token, refresh_token } = response.data;\n    \n    if (token && refresh_token) {\n      storeAuthToken(token, refresh_token);\n    }\n    \n    return response;\n  } catch (error) {\n    console.error('Login error:', error);\n    throw error;\n  }\n};\n\nconst register = async (userData) => {\n  // Clear any existing token before register attempt\n  delete api.defaults.headers.common['Authorization'];\n  \n  try {\n    const response = await api.post('/auth/register', userData);\n    const { token, refresh_token } = response.data;\n    \n    if (token && refresh_token) {\n      storeAuthToken(token, refresh_token);\n    }\n    \n    return response;\n  } catch (error) {\n    console.error('Registration error:', error);\n    throw error;\n  }\n};\n\nconst logout = async () => {\n  try {\n    // Call server-side logout if implemented\n    await api.post('/auth/logout');\n  } catch (error) {\n    // Ignore errors during logout\n    console.warn('Logout error (continuing anyway):', error);\n  } finally {\n    // Always clear local tokens\n    clearAuthToken();\n  }\n};\n\nconst getCurrentUser = () => {\n  setupTokenRefresh(); // Ensure token is set\n  return api.get('/users/me');\n};\n\n// User management\nconst getAllUsers = (params = {}) => {\n  return api.get('/users', { params });\n};\n\nconst getUserById = (userId) => {\n  return api.get(`/users/${userId}`);\n};\n\nconst updateUser = (userId, userData) => {\n  return api.put(`/users/${userId}`, userData);\n};\n\nconst deleteUser = (userId) => {\n  return api.delete(`/users/${userId}`);\n};\n\nconst createUser = (userData) => {\n  return api.post('/users', userData);\n};\n\n// Subscription management\nconst getAllSubscriptionPlans = () => {\n  return api.get('/subscriptions/plans');\n};\n\nconst getUserSubscription = () => {\n  return api.get('/subscriptions/me');\n};\n\nconst createSubscription = (planId) => {\n  return api.post('/subscriptions', { plan_id: planId });\n};\n\nconst cancelSubscription = (reason) => {\n  return api.delete('/subscriptions/me', { \n    data: { reason } \n  });\n};\n\nconst checkSubscription = () => {\n  return api.get('/subscriptions/check');\n};\n\n// Access code management\nconst generateAccessCode = () => {\n  return api.post('/access/generate');\n};\n\nconst getAccessCodes = () => {\n  return api.get('/access/me');\n};\n\nconst redeemAccessCode = (accessCode) => {\n  return api.post('/access/redeem', { code: accessCode });\n};\n\nconst revokeAccessCode = (codeId) => {\n  return api.post(`/access/revoke/${codeId}`);\n};\n\n// Admin functions\nconst getDashboardStats = () => {\n  return api.get('/admin/stats');\n};\n\nconst getAllSubscriptions = (params = {}) => {\n  return api.get('/admin/subscriptions', { params });\n};\n\nconst getUsersWithRoles = (params = {}) => {\n  return api.get('/admin/users', { params });\n};\n\nconst updateUserRole = (userId, role) => {\n  return api.put(`/admin/users/${userId}/role`, { role });\n};\n\n// Favorites\nconst getFavorites = () => {\n  return api.get('/favorites');\n};\n\nconst addToFavorites = (contentId, contentType) => {\n  return api.post('/favorites', { content_id: contentId, content_type: contentType });\n};\n\nconst removeFromFavorites = (contentId) => {\n  return api.delete(`/favorites/${contentId}`);\n};\n\n// Watch history\nconst getWatchHistory = (params = {}) => {\n  return api.get('/history', { params });\n};\n\nconst addToWatchHistory = (contentId, watchDuration, watchPercentage) => {\n  return api.post('/history', { \n    content_id: contentId, \n    watch_duration: watchDuration, \n    watch_percentage: watchPercentage \n  });\n};\n\n// User profiles\nconst getUserProfiles = () => {\n  return api.get('/profile');\n};\n\nconst createProfile = (profileData) => {\n  return api.post('/profile', profileData);\n};\n\nconst updateProfile = (profileId, profileData) => {\n  return api.put(`/profile/${profileId}`, profileData);\n};\n\nconst deleteProfile = (profileId) => {\n  return api.delete(`/profile/${profileId}`);\n};\n\n// Password management\nconst updatePassword = (currentPassword, newPassword) => {\n  return api.post('/users/me/password', { current_password: currentPassword, new_password: newPassword });\n};\n\nconst adminResetUserPassword = (userId, newPassword) => {\n  return api.post(`/admin/users/${userId}/reset-password`, { new_password: newPassword });\n};\n\nconst requestPasswordReset = async (email) => {\n  return api.post('/auth/forgot-password', { email });\n};\n\nconst resetPassword = async (token, newPassword) => {\n  return api.post('/auth/reset-password', { \n    token, \n    new_password: newPassword\n  });\n};\n\nexport {\n  api as default,\n  login,\n  register,\n  logout,\n  getCurrentUser,\n  getAllUsers,\n  getUserById,\n  updateUser,\n  deleteUser,\n  createUser,\n  getAllSubscriptionPlans,\n  getUserSubscription,\n  createSubscription,\n  cancelSubscription,\n  checkSubscription,\n  generateAccessCode,\n  getAccessCodes,\n  redeemAccessCode,\n  revokeAccessCode,\n  getDashboardStats,\n  getAllSubscriptions,\n  getUsersWithRoles,\n  updateUserRole,\n  getFavorites,\n  addToFavorites,\n  removeFromFavorites,\n  getWatchHistory,\n  addToWatchHistory,\n  getUserProfiles,\n  createProfile,\n  updateProfile,\n  deleteProfile,\n  updatePassword,\n  adminResetUserPassword,\n  requestPasswordReset,\n  resetPassword,\n  debugToken,\n  setupTokenRefresh,\n  storeAuthToken,\n  clearAuthToken,\n  refreshAuthToken\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}