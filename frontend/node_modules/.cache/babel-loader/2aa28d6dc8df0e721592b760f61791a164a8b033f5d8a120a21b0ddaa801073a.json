{"ast":null,"code":"import axios from 'axios';\nimport config from '../config/env';\nimport jwtDecode from 'jwt-decode';\n\n// Create axios instance with base URL from environment config\nconst api = axios.create({\n  baseURL: config.API_URL\n});\n\n// Debug function to help troubleshoot token issues\nconst debugToken = token => {\n  if (!token) {\n    return {\n      hasToken: false\n    };\n  }\n  try {\n    // Try to extract data from the token (without verification)\n    const tokenParts = token.split('.');\n    if (tokenParts.length !== 3) {\n      return {\n        hasToken: true,\n        isValidFormat: false,\n        token: `${token.substring(0, 15)}...`\n      };\n    }\n\n    // Decode the payload (middle part)\n    const payload = JSON.parse(atob(tokenParts[1]));\n    const expiry = new Date(payload.exp * 1000).toLocaleString();\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    const isExpired = payload.exp < nowSeconds;\n    const expiresIn = isExpired ? 'Expired' : `${Math.floor((payload.exp - nowSeconds) / 60)} minutes`;\n    return {\n      hasToken: true,\n      isValidFormat: true,\n      token: `${token.substring(0, 15)}...`,\n      subject: payload.sub,\n      role: payload.role,\n      expiry,\n      isExpired,\n      expiresIn,\n      isRefreshToken: !!payload.refresh\n    };\n  } catch (error) {\n    return {\n      hasToken: true,\n      isValidFormat: false,\n      error: error.message\n    };\n  }\n};\n\n// Function to check if token needs refresh\nconst isTokenExpiringSoon = token => {\n  if (!token) return false;\n  try {\n    const payload = jwtDecode(token);\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    // Check if token will expire within the buffer time\n    return payload.exp - nowSeconds < config.TOKEN_EXPIRY_BUFFER;\n  } catch (error) {\n    return false;\n  }\n};\n\n// Track if a refresh is in progress to prevent multiple refreshes\nlet isRefreshingToken = false;\n// Store pending requests that are waiting for token refresh\nlet pendingRequests = [];\n\n// Function to refresh token\nconst refreshAuthToken = async () => {\n  const refreshToken = localStorage.getItem('refreshToken');\n  if (!refreshToken) {\n    return Promise.reject(new Error('No refresh token available'));\n  }\n\n  // Prevent multiple simultaneous refresh requests\n  if (isRefreshingToken) {\n    return new Promise((resolve, reject) => {\n      pendingRequests.push({\n        resolve,\n        reject\n      });\n    });\n  }\n  isRefreshingToken = true;\n  try {\n    // We need to use a clean axios instance for the refresh request\n    // to avoid authorization header and interceptors\n    const response = await axios.post(`${config.API_URL}/auth/refresh`, {\n      refresh_token: refreshToken\n    });\n    const newToken = response.data.token;\n    if (newToken) {\n      // Store the new token\n      localStorage.setItem('token', newToken);\n      // Update axios headers\n      api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;\n\n      // Process any pending requests\n      pendingRequests.forEach(request => {\n        request.resolve(newToken);\n      });\n      pendingRequests = [];\n      return newToken;\n    } else {\n      throw new Error('Failed to refresh token');\n    }\n  } catch (error) {\n    // If refresh fails, reject all pending requests\n    pendingRequests.forEach(request => {\n      request.reject(error);\n    });\n    pendingRequests = [];\n\n    // Clear tokens on refresh failure\n    localStorage.removeItem('token');\n    localStorage.removeItem('refreshToken');\n    throw error;\n  } finally {\n    isRefreshingToken = false;\n  }\n};\n\n// Ensure the token is correctly set up for all requests\nconst setupTokenRefresh = () => {\n  const token = localStorage.getItem('token');\n  if (token) {\n    // Update both instances of axios\n    api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n\n    // Return token info for debugging\n    return debugToken(token);\n  } else {\n    delete api.defaults.headers.common['Authorization'];\n    return {\n      hasToken: false\n    };\n  }\n};\n\n// Function to store token in a consistent way\nconst storeAuthToken = (token, refreshToken) => {\n  if (!token) {\n    console.warn('Attempted to store empty token');\n    return false;\n  }\n  try {\n    // Store in localStorage\n    localStorage.setItem('token', token);\n\n    // Store refresh token if provided\n    if (refreshToken) {\n      localStorage.setItem('refreshToken', refreshToken);\n    }\n\n    // Update axios headers\n    api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    if (config.ENABLE_LOGGING) {\n      console.log('Token stored and headers set');\n    }\n    return true;\n  } catch (error) {\n    console.error('Error storing token:', error);\n    return false;\n  }\n};\n\n// Function to clear auth token completely\nconst clearAuthToken = () => {\n  try {\n    localStorage.removeItem('token');\n    localStorage.removeItem('refreshToken');\n    delete api.defaults.headers.common['Authorization'];\n    if (config.ENABLE_LOGGING) {\n      console.log('Auth tokens cleared');\n    }\n    return true;\n  } catch (error) {\n    console.error('Error clearing token:', error);\n    return false;\n  }\n};\n\n// Call this once at import time\nsetupTokenRefresh();\n\n// Add a request interceptor to include token with each request and handle token refresh\napi.interceptors.request.use(async config => {\n  // Always get fresh token for each request\n  const token = localStorage.getItem('token');\n  if (token) {\n    // Check if token is about to expire and needs refresh\n    if (isTokenExpiringSoon(token) && !config.url.includes('/auth/refresh')) {\n      try {\n        // Try to refresh the token\n        const newToken = await refreshAuthToken();\n        // Update the request with the new token\n        config.headers.Authorization = `Bearer ${newToken}`;\n      } catch (error) {\n        // If refresh fails but we still have the old token, use it anyway\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n    } else {\n      // Use the current token\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n  }\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\n\n// Add a response interceptor to handle 401 errors\napi.interceptors.response.use(response => {\n  return response;\n}, async error => {\n  // Get the original request configuration\n  const originalRequest = error.config;\n\n  // If we get a 401 error and haven't tried to refresh the token for this request yet\n  if (error.response && error.response.status === 401 && !originalRequest._retry) {\n    // Don't attempt refresh for auth endpoints to avoid infinite loops\n    if (originalRequest.url.includes('/auth/login') || originalRequest.url.includes('/auth/refresh')) {\n      // Just propagate the error for auth endpoints\n      clearAuthToken();\n      return Promise.reject(error);\n    }\n\n    // Mark this request as retried\n    originalRequest._retry = true;\n    try {\n      // Attempt to refresh the token\n      const newToken = await refreshAuthToken();\n\n      // Update the failed request with the new token\n      originalRequest.headers.Authorization = `Bearer ${newToken}`;\n\n      // Retry the original request with the new token\n      return api(originalRequest);\n    } catch (refreshError) {\n      // If refresh fails, clear tokens and redirect to login\n      clearAuthToken();\n\n      // Propagate the original error\n      return Promise.reject(error);\n    }\n  }\n\n  // For other errors, just propagate\n  return Promise.reject(error);\n});\n\n// Authentication\nconst login = async credentials => {\n  // Clear any existing token before login attempt\n  delete api.defaults.headers.common['Authorization'];\n  try {\n    const response = await api.post('/auth/login', credentials);\n    const {\n      token,\n      refresh_token\n    } = response.data;\n    if (token && refresh_token) {\n      storeAuthToken(token, refresh_token);\n    }\n    return response;\n  } catch (error) {\n    console.error('Login error:', error);\n    throw error;\n  }\n};\nconst register = async userData => {\n  // Clear any existing token before register attempt\n  delete api.defaults.headers.common['Authorization'];\n  try {\n    const response = await api.post('/auth/register', userData);\n    const {\n      token,\n      refresh_token\n    } = response.data;\n    if (token && refresh_token) {\n      storeAuthToken(token, refresh_token);\n    }\n    return response;\n  } catch (error) {\n    console.error('Registration error:', error);\n    throw error;\n  }\n};\nconst logout = async () => {\n  try {\n    // Call server-side logout if implemented\n    await api.post('/auth/logout');\n  } catch (error) {\n    // Ignore errors during logout\n    console.warn('Logout error (continuing anyway):', error);\n  } finally {\n    // Always clear local tokens\n    clearAuthToken();\n  }\n};\nconst getCurrentUser = () => {\n  setupTokenRefresh(); // Ensure token is set\n  return api.get('/users/me');\n};\n\n// User management\nconst getAllUsers = (params = {}) => {\n  return api.get('/users', {\n    params\n  });\n};\nconst getUserById = userId => {\n  return api.get(`/users/${userId}`);\n};\nconst updateUser = (userId, userData) => {\n  return api.put(`/users/${userId}`, userData);\n};\nconst deleteUser = userId => {\n  return api.delete(`/users/${userId}`);\n};\nconst createUser = userData => {\n  return api.post('/users', userData);\n};\n\n// Subscription management\nconst getAllSubscriptionPlans = () => {\n  return api.get('/subscriptions/plans');\n};\nconst getUserSubscription = () => {\n  return api.get('/subscriptions/me');\n};\nconst createSubscription = planId => {\n  return api.post('/subscriptions', {\n    plan_id: planId\n  });\n};\nconst cancelSubscription = reason => {\n  return api.delete('/subscriptions/me', {\n    data: {\n      reason\n    }\n  });\n};\nconst checkSubscription = () => {\n  return api.get('/subscriptions/check');\n};\n\n// Access code management\nconst generateAccessCode = () => {\n  return api.post('/access/generate');\n};\nconst getAccessCodes = () => {\n  return api.get('/access/me');\n};\nconst redeemAccessCode = accessCode => {\n  return api.post('/access/redeem', {\n    code: accessCode\n  });\n};\nconst revokeAccessCode = codeId => {\n  return api.post(`/access/revoke/${codeId}`);\n};\n\n// Admin functions\nconst getDashboardStats = () => {\n  return api.get('/admin/stats');\n};\nconst getAllSubscriptions = (params = {}) => {\n  return api.get('/admin/subscriptions', {\n    params\n  });\n};\nconst getUsersWithRoles = (params = {}) => {\n  return api.get('/admin/users', {\n    params\n  });\n};\nconst updateUserRole = (userId, role) => {\n  return api.put(`/admin/users/${userId}/role`, {\n    role\n  });\n};\n\n// Favorites\nconst getFavorites = () => {\n  return api.get('/favorites');\n};\nconst addToFavorites = (contentId, contentType) => {\n  return api.post('/favorites', {\n    content_id: contentId,\n    content_type: contentType\n  });\n};\nconst removeFromFavorites = contentId => {\n  return api.delete(`/favorites/${contentId}`);\n};\n\n// Watch history\nconst getWatchHistory = (params = {}) => {\n  return api.get('/history', {\n    params\n  });\n};\nconst addToWatchHistory = (contentId, watchDuration, watchPercentage) => {\n  return api.post('/history', {\n    content_id: contentId,\n    watch_duration: watchDuration,\n    watch_percentage: watchPercentage\n  });\n};\n\n// User profiles\nconst getUserProfiles = () => {\n  return api.get('/profile');\n};\nconst createProfile = profileData => {\n  return api.post('/profile', profileData);\n};\nconst updateProfile = (profileId, profileData) => {\n  return api.put(`/profile/${profileId}`, profileData);\n};\nconst deleteProfile = profileId => {\n  return api.delete(`/profile/${profileId}`);\n};\n\n// Password management\nconst updatePassword = (currentPassword, newPassword) => {\n  return api.post('/users/me/password', {\n    current_password: currentPassword,\n    new_password: newPassword\n  });\n};\nconst adminResetUserPassword = (userId, newPassword) => {\n  return api.post(`/admin/users/${userId}/reset-password`, {\n    new_password: newPassword\n  });\n};\nconst requestPasswordReset = async email => {\n  return api.post('/auth/forgot-password', {\n    email\n  });\n};\nconst resetPassword = async (token, newPassword) => {\n  return api.post('/auth/reset-password', {\n    token,\n    new_password: newPassword\n  });\n};\nexport { api as default, login, register, logout, getCurrentUser, getAllUsers, getUserById, updateUser, deleteUser, createUser, getAllSubscriptionPlans, getUserSubscription, createSubscription, cancelSubscription, checkSubscription, generateAccessCode, getAccessCodes, redeemAccessCode, revokeAccessCode, getDashboardStats, getAllSubscriptions, getUsersWithRoles, updateUserRole, getFavorites, addToFavorites, removeFromFavorites, getWatchHistory, addToWatchHistory, getUserProfiles, createProfile, updateProfile, deleteProfile, updatePassword, adminResetUserPassword, requestPasswordReset, resetPassword, debugToken, setupTokenRefresh, storeAuthToken, clearAuthToken, refreshAuthToken };","map":{"version":3,"names":["axios","config","jwtDecode","api","create","baseURL","API_URL","debugToken","token","hasToken","tokenParts","split","length","isValidFormat","substring","payload","JSON","parse","atob","expiry","Date","exp","toLocaleString","nowSeconds","Math","floor","now","isExpired","expiresIn","subject","sub","role","isRefreshToken","refresh","error","message","isTokenExpiringSoon","TOKEN_EXPIRY_BUFFER","isRefreshingToken","pendingRequests","refreshAuthToken","refreshToken","localStorage","getItem","Promise","reject","Error","resolve","push","response","post","refresh_token","newToken","data","setItem","defaults","headers","common","forEach","request","removeItem","setupTokenRefresh","storeAuthToken","console","warn","ENABLE_LOGGING","log","clearAuthToken","interceptors","use","url","includes","Authorization","originalRequest","status","_retry","refreshError","login","credentials","register","userData","logout","getCurrentUser","get","getAllUsers","params","getUserById","userId","updateUser","put","deleteUser","delete","createUser","getAllSubscriptionPlans","getUserSubscription","createSubscription","planId","plan_id","cancelSubscription","reason","checkSubscription","generateAccessCode","getAccessCodes","redeemAccessCode","accessCode","code","revokeAccessCode","codeId","getDashboardStats","getAllSubscriptions","getUsersWithRoles","updateUserRole","getFavorites","addToFavorites","contentId","contentType","content_id","content_type","removeFromFavorites","getWatchHistory","addToWatchHistory","watchDuration","watchPercentage","watch_duration","watch_percentage","getUserProfiles","createProfile","profileData","updateProfile","profileId","deleteProfile","updatePassword","currentPassword","newPassword","current_password","new_password","adminResetUserPassword","requestPasswordReset","email","resetPassword","default"],"sources":["D:/Movie/frontend/src/api/backendApi.js"],"sourcesContent":["import axios from 'axios';\nimport config from '../config/env';\nimport jwtDecode from 'jwt-decode';\n\n// Create axios instance with base URL from environment config\nconst api = axios.create({\n  baseURL: config.API_URL\n});\n\n// Debug function to help troubleshoot token issues\nconst debugToken = (token) => {\n  if (!token) {\n    return { hasToken: false };\n  }\n\n  try {\n    // Try to extract data from the token (without verification)\n    const tokenParts = token.split('.');\n    if (tokenParts.length !== 3) {\n      return { hasToken: true, isValidFormat: false, token: `${token.substring(0, 15)}...` };\n    }\n\n    // Decode the payload (middle part)\n    const payload = JSON.parse(atob(tokenParts[1]));\n    const expiry = new Date(payload.exp * 1000).toLocaleString();\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    const isExpired = payload.exp < nowSeconds;\n    const expiresIn = isExpired \n      ? 'Expired' \n      : `${Math.floor((payload.exp - nowSeconds) / 60)} minutes`;\n\n    return {\n      hasToken: true,\n      isValidFormat: true,\n      token: `${token.substring(0, 15)}...`,\n      subject: payload.sub,\n      role: payload.role,\n      expiry,\n      isExpired,\n      expiresIn,\n      isRefreshToken: !!payload.refresh\n    };\n  } catch (error) {\n    return { hasToken: true, isValidFormat: false, error: error.message };\n  }\n};\n\n// Function to check if token needs refresh\nconst isTokenExpiringSoon = (token) => {\n  if (!token) return false;\n  \n  try {\n    const payload = jwtDecode(token);\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    // Check if token will expire within the buffer time\n    return payload.exp - nowSeconds < config.TOKEN_EXPIRY_BUFFER;\n  } catch (error) {\n    return false;\n  }\n};\n\n// Track if a refresh is in progress to prevent multiple refreshes\nlet isRefreshingToken = false;\n// Store pending requests that are waiting for token refresh\nlet pendingRequests = [];\n\n// Function to refresh token\nconst refreshAuthToken = async () => {\n  const refreshToken = localStorage.getItem('refreshToken');\n  if (!refreshToken) {\n    return Promise.reject(new Error('No refresh token available'));\n  }\n  \n  // Prevent multiple simultaneous refresh requests\n  if (isRefreshingToken) {\n    return new Promise((resolve, reject) => {\n      pendingRequests.push({ resolve, reject });\n    });\n  }\n  \n  isRefreshingToken = true;\n  \n  try {\n    // We need to use a clean axios instance for the refresh request\n    // to avoid authorization header and interceptors\n    const response = await axios.post(`${config.API_URL}/auth/refresh`, { \n      refresh_token: refreshToken \n    });\n    \n    const newToken = response.data.token;\n    if (newToken) {\n      // Store the new token\n      localStorage.setItem('token', newToken);\n      // Update axios headers\n      api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;\n      \n      // Process any pending requests\n      pendingRequests.forEach(request => {\n        request.resolve(newToken);\n      });\n      pendingRequests = [];\n      \n      return newToken;\n    } else {\n      throw new Error('Failed to refresh token');\n    }\n  } catch (error) {\n    // If refresh fails, reject all pending requests\n    pendingRequests.forEach(request => {\n      request.reject(error);\n    });\n    pendingRequests = [];\n    \n    // Clear tokens on refresh failure\n    localStorage.removeItem('token');\n    localStorage.removeItem('refreshToken');\n    \n    throw error;\n  } finally {\n    isRefreshingToken = false;\n  }\n};\n\n// Ensure the token is correctly set up for all requests\nconst setupTokenRefresh = () => {\n  const token = localStorage.getItem('token');\n  if (token) {\n    // Update both instances of axios\n    api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    \n    // Return token info for debugging\n    return debugToken(token);\n  } else {\n    delete api.defaults.headers.common['Authorization'];\n    return { hasToken: false };\n  }\n};\n\n// Function to store token in a consistent way\nconst storeAuthToken = (token, refreshToken) => {\n  if (!token) {\n    console.warn('Attempted to store empty token');\n    return false;\n  }\n  \n  try {\n    // Store in localStorage\n    localStorage.setItem('token', token);\n    \n    // Store refresh token if provided\n    if (refreshToken) {\n      localStorage.setItem('refreshToken', refreshToken);\n    }\n    \n    // Update axios headers\n    api.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    \n    if (config.ENABLE_LOGGING) {\n      console.log('Token stored and headers set');\n    }\n    return true;\n  } catch (error) {\n    console.error('Error storing token:', error);\n    return false;\n  }\n};\n\n// Function to clear auth token completely\nconst clearAuthToken = () => {\n  try {\n    localStorage.removeItem('token');\n    localStorage.removeItem('refreshToken');\n    delete api.defaults.headers.common['Authorization'];\n    \n    if (config.ENABLE_LOGGING) {\n      console.log('Auth tokens cleared');\n    }\n    return true;\n  } catch (error) {\n    console.error('Error clearing token:', error);\n    return false;\n  }\n};\n\n// Call this once at import time\nsetupTokenRefresh();\n\n// Add a request interceptor to include token with each request and handle token refresh\napi.interceptors.request.use(\n  async (config) => {\n    // Always get fresh token for each request\n    const token = localStorage.getItem('token');\n    \n    if (token) {\n      // Check if token is about to expire and needs refresh\n      if (isTokenExpiringSoon(token) && !config.url.includes('/auth/refresh')) {\n        try {\n          // Try to refresh the token\n          const newToken = await refreshAuthToken();\n          // Update the request with the new token\n          config.headers.Authorization = `Bearer ${newToken}`;\n        } catch (error) {\n          // If refresh fails but we still have the old token, use it anyway\n          config.headers.Authorization = `Bearer ${token}`;\n        }\n      } else {\n        // Use the current token\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n    }\n    \n    return config;\n  },\n  (error) => {\n    return Promise.reject(error);\n  }\n);\n\n// Add a response interceptor to handle 401 errors\napi.interceptors.response.use(\n  (response) => {\n    return response;\n  },\n  async (error) => {\n    // Get the original request configuration\n    const originalRequest = error.config;\n    \n    // If we get a 401 error and haven't tried to refresh the token for this request yet\n    if (error.response && error.response.status === 401 && !originalRequest._retry) {\n      // Don't attempt refresh for auth endpoints to avoid infinite loops\n      if (originalRequest.url.includes('/auth/login') || \n          originalRequest.url.includes('/auth/refresh')) {\n        // Just propagate the error for auth endpoints\n        clearAuthToken();\n        return Promise.reject(error);\n      }\n      \n      // Mark this request as retried\n      originalRequest._retry = true;\n      \n      try {\n        // Attempt to refresh the token\n        const newToken = await refreshAuthToken();\n        \n        // Update the failed request with the new token\n        originalRequest.headers.Authorization = `Bearer ${newToken}`;\n        \n        // Retry the original request with the new token\n        return api(originalRequest);\n      } catch (refreshError) {\n        // If refresh fails, clear tokens and redirect to login\n        clearAuthToken();\n        \n        // Propagate the original error\n        return Promise.reject(error);\n      }\n    }\n    \n    // For other errors, just propagate\n    return Promise.reject(error);\n  }\n);\n\n// Authentication\nconst login = async (credentials) => {\n  // Clear any existing token before login attempt\n  delete api.defaults.headers.common['Authorization'];\n  try {\n    const response = await api.post('/auth/login', credentials);\n    const { token, refresh_token } = response.data;\n    \n    if (token && refresh_token) {\n      storeAuthToken(token, refresh_token);\n    }\n    \n    return response;\n  } catch (error) {\n    console.error('Login error:', error);\n    throw error;\n  }\n};\n\nconst register = async (userData) => {\n  // Clear any existing token before register attempt\n  delete api.defaults.headers.common['Authorization'];\n  \n  try {\n    const response = await api.post('/auth/register', userData);\n    const { token, refresh_token } = response.data;\n    \n    if (token && refresh_token) {\n      storeAuthToken(token, refresh_token);\n    }\n    \n    return response;\n  } catch (error) {\n    console.error('Registration error:', error);\n    throw error;\n  }\n};\n\nconst logout = async () => {\n  try {\n    // Call server-side logout if implemented\n    await api.post('/auth/logout');\n  } catch (error) {\n    // Ignore errors during logout\n    console.warn('Logout error (continuing anyway):', error);\n  } finally {\n    // Always clear local tokens\n    clearAuthToken();\n  }\n};\n\nconst getCurrentUser = () => {\n  setupTokenRefresh(); // Ensure token is set\n  return api.get('/users/me');\n};\n\n// User management\nconst getAllUsers = (params = {}) => {\n  return api.get('/users', { params });\n};\n\nconst getUserById = (userId) => {\n  return api.get(`/users/${userId}`);\n};\n\nconst updateUser = (userId, userData) => {\n  return api.put(`/users/${userId}`, userData);\n};\n\nconst deleteUser = (userId) => {\n  return api.delete(`/users/${userId}`);\n};\n\nconst createUser = (userData) => {\n  return api.post('/users', userData);\n};\n\n// Subscription management\nconst getAllSubscriptionPlans = () => {\n  return api.get('/subscriptions/plans');\n};\n\nconst getUserSubscription = () => {\n  return api.get('/subscriptions/me');\n};\n\nconst createSubscription = (planId) => {\n  return api.post('/subscriptions', { plan_id: planId });\n};\n\nconst cancelSubscription = (reason) => {\n  return api.delete('/subscriptions/me', { \n    data: { reason } \n  });\n};\n\nconst checkSubscription = () => {\n  return api.get('/subscriptions/check');\n};\n\n// Access code management\nconst generateAccessCode = () => {\n  return api.post('/access/generate');\n};\n\nconst getAccessCodes = () => {\n  return api.get('/access/me');\n};\n\nconst redeemAccessCode = (accessCode) => {\n  return api.post('/access/redeem', { code: accessCode });\n};\n\nconst revokeAccessCode = (codeId) => {\n  return api.post(`/access/revoke/${codeId}`);\n};\n\n// Admin functions\nconst getDashboardStats = () => {\n  return api.get('/admin/stats');\n};\n\nconst getAllSubscriptions = (params = {}) => {\n  return api.get('/admin/subscriptions', { params });\n};\n\nconst getUsersWithRoles = (params = {}) => {\n  return api.get('/admin/users', { params });\n};\n\nconst updateUserRole = (userId, role) => {\n  return api.put(`/admin/users/${userId}/role`, { role });\n};\n\n// Favorites\nconst getFavorites = () => {\n  return api.get('/favorites');\n};\n\nconst addToFavorites = (contentId, contentType) => {\n  return api.post('/favorites', { content_id: contentId, content_type: contentType });\n};\n\nconst removeFromFavorites = (contentId) => {\n  return api.delete(`/favorites/${contentId}`);\n};\n\n// Watch history\nconst getWatchHistory = (params = {}) => {\n  return api.get('/history', { params });\n};\n\nconst addToWatchHistory = (contentId, watchDuration, watchPercentage) => {\n  return api.post('/history', { \n    content_id: contentId, \n    watch_duration: watchDuration, \n    watch_percentage: watchPercentage \n  });\n};\n\n// User profiles\nconst getUserProfiles = () => {\n  return api.get('/profile');\n};\n\nconst createProfile = (profileData) => {\n  return api.post('/profile', profileData);\n};\n\nconst updateProfile = (profileId, profileData) => {\n  return api.put(`/profile/${profileId}`, profileData);\n};\n\nconst deleteProfile = (profileId) => {\n  return api.delete(`/profile/${profileId}`);\n};\n\n// Password management\nconst updatePassword = (currentPassword, newPassword) => {\n  return api.post('/users/me/password', { current_password: currentPassword, new_password: newPassword });\n};\n\nconst adminResetUserPassword = (userId, newPassword) => {\n  return api.post(`/admin/users/${userId}/reset-password`, { new_password: newPassword });\n};\n\nconst requestPasswordReset = async (email) => {\n  return api.post('/auth/forgot-password', { email });\n};\n\nconst resetPassword = async (token, newPassword) => {\n  return api.post('/auth/reset-password', { \n    token, \n    new_password: newPassword\n  });\n};\n\nexport {\n  api as default,\n  login,\n  register,\n  logout,\n  getCurrentUser,\n  getAllUsers,\n  getUserById,\n  updateUser,\n  deleteUser,\n  createUser,\n  getAllSubscriptionPlans,\n  getUserSubscription,\n  createSubscription,\n  cancelSubscription,\n  checkSubscription,\n  generateAccessCode,\n  getAccessCodes,\n  redeemAccessCode,\n  revokeAccessCode,\n  getDashboardStats,\n  getAllSubscriptions,\n  getUsersWithRoles,\n  updateUserRole,\n  getFavorites,\n  addToFavorites,\n  removeFromFavorites,\n  getWatchHistory,\n  addToWatchHistory,\n  getUserProfiles,\n  createProfile,\n  updateProfile,\n  deleteProfile,\n  updatePassword,\n  adminResetUserPassword,\n  requestPasswordReset,\n  resetPassword,\n  debugToken,\n  setupTokenRefresh,\n  storeAuthToken,\n  clearAuthToken,\n  refreshAuthToken\n}; "],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,MAAM,MAAM,eAAe;AAClC,OAAOC,SAAS,MAAM,YAAY;;AAElC;AACA,MAAMC,GAAG,GAAGH,KAAK,CAACI,MAAM,CAAC;EACvBC,OAAO,EAAEJ,MAAM,CAACK;AAClB,CAAC,CAAC;;AAEF;AACA,MAAMC,UAAU,GAAIC,KAAK,IAAK;EAC5B,IAAI,CAACA,KAAK,EAAE;IACV,OAAO;MAAEC,QAAQ,EAAE;IAAM,CAAC;EAC5B;EAEA,IAAI;IACF;IACA,MAAMC,UAAU,GAAGF,KAAK,CAACG,KAAK,CAAC,GAAG,CAAC;IACnC,IAAID,UAAU,CAACE,MAAM,KAAK,CAAC,EAAE;MAC3B,OAAO;QAAEH,QAAQ,EAAE,IAAI;QAAEI,aAAa,EAAE,KAAK;QAAEL,KAAK,EAAE,GAAGA,KAAK,CAACM,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC;MAAM,CAAC;IACxF;;IAEA;IACA,MAAMC,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACR,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/C,MAAMS,MAAM,GAAG,IAAIC,IAAI,CAACL,OAAO,CAACM,GAAG,GAAG,IAAI,CAAC,CAACC,cAAc,CAAC,CAAC;IAC5D,MAAMC,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACL,IAAI,CAACM,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;IAChD,MAAMC,SAAS,GAAGZ,OAAO,CAACM,GAAG,GAAGE,UAAU;IAC1C,MAAMK,SAAS,GAAGD,SAAS,GACvB,SAAS,GACT,GAAGH,IAAI,CAACC,KAAK,CAAC,CAACV,OAAO,CAACM,GAAG,GAAGE,UAAU,IAAI,EAAE,CAAC,UAAU;IAE5D,OAAO;MACLd,QAAQ,EAAE,IAAI;MACdI,aAAa,EAAE,IAAI;MACnBL,KAAK,EAAE,GAAGA,KAAK,CAACM,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK;MACrCe,OAAO,EAAEd,OAAO,CAACe,GAAG;MACpBC,IAAI,EAAEhB,OAAO,CAACgB,IAAI;MAClBZ,MAAM;MACNQ,SAAS;MACTC,SAAS;MACTI,cAAc,EAAE,CAAC,CAACjB,OAAO,CAACkB;IAC5B,CAAC;EACH,CAAC,CAAC,OAAOC,KAAK,EAAE;IACd,OAAO;MAAEzB,QAAQ,EAAE,IAAI;MAAEI,aAAa,EAAE,KAAK;MAAEqB,KAAK,EAAEA,KAAK,CAACC;IAAQ,CAAC;EACvE;AACF,CAAC;;AAED;AACA,MAAMC,mBAAmB,GAAI5B,KAAK,IAAK;EACrC,IAAI,CAACA,KAAK,EAAE,OAAO,KAAK;EAExB,IAAI;IACF,MAAMO,OAAO,GAAGb,SAAS,CAACM,KAAK,CAAC;IAChC,MAAMe,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACL,IAAI,CAACM,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;IAChD;IACA,OAAOX,OAAO,CAACM,GAAG,GAAGE,UAAU,GAAGtB,MAAM,CAACoC,mBAAmB;EAC9D,CAAC,CAAC,OAAOH,KAAK,EAAE;IACd,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA,IAAII,iBAAiB,GAAG,KAAK;AAC7B;AACA,IAAIC,eAAe,GAAG,EAAE;;AAExB;AACA,MAAMC,gBAAgB,GAAG,MAAAA,CAAA,KAAY;EACnC,MAAMC,YAAY,GAAGC,YAAY,CAACC,OAAO,CAAC,cAAc,CAAC;EACzD,IAAI,CAACF,YAAY,EAAE;IACjB,OAAOG,OAAO,CAACC,MAAM,CAAC,IAAIC,KAAK,CAAC,4BAA4B,CAAC,CAAC;EAChE;;EAEA;EACA,IAAIR,iBAAiB,EAAE;IACrB,OAAO,IAAIM,OAAO,CAAC,CAACG,OAAO,EAAEF,MAAM,KAAK;MACtCN,eAAe,CAACS,IAAI,CAAC;QAAED,OAAO;QAAEF;MAAO,CAAC,CAAC;IAC3C,CAAC,CAAC;EACJ;EAEAP,iBAAiB,GAAG,IAAI;EAExB,IAAI;IACF;IACA;IACA,MAAMW,QAAQ,GAAG,MAAMjD,KAAK,CAACkD,IAAI,CAAC,GAAGjD,MAAM,CAACK,OAAO,eAAe,EAAE;MAClE6C,aAAa,EAAEV;IACjB,CAAC,CAAC;IAEF,MAAMW,QAAQ,GAAGH,QAAQ,CAACI,IAAI,CAAC7C,KAAK;IACpC,IAAI4C,QAAQ,EAAE;MACZ;MACAV,YAAY,CAACY,OAAO,CAAC,OAAO,EAAEF,QAAQ,CAAC;MACvC;MACAjD,GAAG,CAACoD,QAAQ,CAACC,OAAO,CAACC,MAAM,CAAC,eAAe,CAAC,GAAG,UAAUL,QAAQ,EAAE;;MAEnE;MACAb,eAAe,CAACmB,OAAO,CAACC,OAAO,IAAI;QACjCA,OAAO,CAACZ,OAAO,CAACK,QAAQ,CAAC;MAC3B,CAAC,CAAC;MACFb,eAAe,GAAG,EAAE;MAEpB,OAAOa,QAAQ;IACjB,CAAC,MAAM;MACL,MAAM,IAAIN,KAAK,CAAC,yBAAyB,CAAC;IAC5C;EACF,CAAC,CAAC,OAAOZ,KAAK,EAAE;IACd;IACAK,eAAe,CAACmB,OAAO,CAACC,OAAO,IAAI;MACjCA,OAAO,CAACd,MAAM,CAACX,KAAK,CAAC;IACvB,CAAC,CAAC;IACFK,eAAe,GAAG,EAAE;;IAEpB;IACAG,YAAY,CAACkB,UAAU,CAAC,OAAO,CAAC;IAChClB,YAAY,CAACkB,UAAU,CAAC,cAAc,CAAC;IAEvC,MAAM1B,KAAK;EACb,CAAC,SAAS;IACRI,iBAAiB,GAAG,KAAK;EAC3B;AACF,CAAC;;AAED;AACA,MAAMuB,iBAAiB,GAAGA,CAAA,KAAM;EAC9B,MAAMrD,KAAK,GAAGkC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;EAC3C,IAAInC,KAAK,EAAE;IACT;IACAL,GAAG,CAACoD,QAAQ,CAACC,OAAO,CAACC,MAAM,CAAC,eAAe,CAAC,GAAG,UAAUjD,KAAK,EAAE;;IAEhE;IACA,OAAOD,UAAU,CAACC,KAAK,CAAC;EAC1B,CAAC,MAAM;IACL,OAAOL,GAAG,CAACoD,QAAQ,CAACC,OAAO,CAACC,MAAM,CAAC,eAAe,CAAC;IACnD,OAAO;MAAEhD,QAAQ,EAAE;IAAM,CAAC;EAC5B;AACF,CAAC;;AAED;AACA,MAAMqD,cAAc,GAAGA,CAACtD,KAAK,EAAEiC,YAAY,KAAK;EAC9C,IAAI,CAACjC,KAAK,EAAE;IACVuD,OAAO,CAACC,IAAI,CAAC,gCAAgC,CAAC;IAC9C,OAAO,KAAK;EACd;EAEA,IAAI;IACF;IACAtB,YAAY,CAACY,OAAO,CAAC,OAAO,EAAE9C,KAAK,CAAC;;IAEpC;IACA,IAAIiC,YAAY,EAAE;MAChBC,YAAY,CAACY,OAAO,CAAC,cAAc,EAAEb,YAAY,CAAC;IACpD;;IAEA;IACAtC,GAAG,CAACoD,QAAQ,CAACC,OAAO,CAACC,MAAM,CAAC,eAAe,CAAC,GAAG,UAAUjD,KAAK,EAAE;IAEhE,IAAIP,MAAM,CAACgE,cAAc,EAAE;MACzBF,OAAO,CAACG,GAAG,CAAC,8BAA8B,CAAC;IAC7C;IACA,OAAO,IAAI;EACb,CAAC,CAAC,OAAOhC,KAAK,EAAE;IACd6B,OAAO,CAAC7B,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;IAC5C,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA,MAAMiC,cAAc,GAAGA,CAAA,KAAM;EAC3B,IAAI;IACFzB,YAAY,CAACkB,UAAU,CAAC,OAAO,CAAC;IAChClB,YAAY,CAACkB,UAAU,CAAC,cAAc,CAAC;IACvC,OAAOzD,GAAG,CAACoD,QAAQ,CAACC,OAAO,CAACC,MAAM,CAAC,eAAe,CAAC;IAEnD,IAAIxD,MAAM,CAACgE,cAAc,EAAE;MACzBF,OAAO,CAACG,GAAG,CAAC,qBAAqB,CAAC;IACpC;IACA,OAAO,IAAI;EACb,CAAC,CAAC,OAAOhC,KAAK,EAAE;IACd6B,OAAO,CAAC7B,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;IAC7C,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA2B,iBAAiB,CAAC,CAAC;;AAEnB;AACA1D,GAAG,CAACiE,YAAY,CAACT,OAAO,CAACU,GAAG,CAC1B,MAAOpE,MAAM,IAAK;EAChB;EACA,MAAMO,KAAK,GAAGkC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;EAE3C,IAAInC,KAAK,EAAE;IACT;IACA,IAAI4B,mBAAmB,CAAC5B,KAAK,CAAC,IAAI,CAACP,MAAM,CAACqE,GAAG,CAACC,QAAQ,CAAC,eAAe,CAAC,EAAE;MACvE,IAAI;QACF;QACA,MAAMnB,QAAQ,GAAG,MAAMZ,gBAAgB,CAAC,CAAC;QACzC;QACAvC,MAAM,CAACuD,OAAO,CAACgB,aAAa,GAAG,UAAUpB,QAAQ,EAAE;MACrD,CAAC,CAAC,OAAOlB,KAAK,EAAE;QACd;QACAjC,MAAM,CAACuD,OAAO,CAACgB,aAAa,GAAG,UAAUhE,KAAK,EAAE;MAClD;IACF,CAAC,MAAM;MACL;MACAP,MAAM,CAACuD,OAAO,CAACgB,aAAa,GAAG,UAAUhE,KAAK,EAAE;IAClD;EACF;EAEA,OAAOP,MAAM;AACf,CAAC,EACAiC,KAAK,IAAK;EACT,OAAOU,OAAO,CAACC,MAAM,CAACX,KAAK,CAAC;AAC9B,CACF,CAAC;;AAED;AACA/B,GAAG,CAACiE,YAAY,CAACnB,QAAQ,CAACoB,GAAG,CAC1BpB,QAAQ,IAAK;EACZ,OAAOA,QAAQ;AACjB,CAAC,EACD,MAAOf,KAAK,IAAK;EACf;EACA,MAAMuC,eAAe,GAAGvC,KAAK,CAACjC,MAAM;;EAEpC;EACA,IAAIiC,KAAK,CAACe,QAAQ,IAAIf,KAAK,CAACe,QAAQ,CAACyB,MAAM,KAAK,GAAG,IAAI,CAACD,eAAe,CAACE,MAAM,EAAE;IAC9E;IACA,IAAIF,eAAe,CAACH,GAAG,CAACC,QAAQ,CAAC,aAAa,CAAC,IAC3CE,eAAe,CAACH,GAAG,CAACC,QAAQ,CAAC,eAAe,CAAC,EAAE;MACjD;MACAJ,cAAc,CAAC,CAAC;MAChB,OAAOvB,OAAO,CAACC,MAAM,CAACX,KAAK,CAAC;IAC9B;;IAEA;IACAuC,eAAe,CAACE,MAAM,GAAG,IAAI;IAE7B,IAAI;MACF;MACA,MAAMvB,QAAQ,GAAG,MAAMZ,gBAAgB,CAAC,CAAC;;MAEzC;MACAiC,eAAe,CAACjB,OAAO,CAACgB,aAAa,GAAG,UAAUpB,QAAQ,EAAE;;MAE5D;MACA,OAAOjD,GAAG,CAACsE,eAAe,CAAC;IAC7B,CAAC,CAAC,OAAOG,YAAY,EAAE;MACrB;MACAT,cAAc,CAAC,CAAC;;MAEhB;MACA,OAAOvB,OAAO,CAACC,MAAM,CAACX,KAAK,CAAC;IAC9B;EACF;;EAEA;EACA,OAAOU,OAAO,CAACC,MAAM,CAACX,KAAK,CAAC;AAC9B,CACF,CAAC;;AAED;AACA,MAAM2C,KAAK,GAAG,MAAOC,WAAW,IAAK;EACnC;EACA,OAAO3E,GAAG,CAACoD,QAAQ,CAACC,OAAO,CAACC,MAAM,CAAC,eAAe,CAAC;EACnD,IAAI;IACF,MAAMR,QAAQ,GAAG,MAAM9C,GAAG,CAAC+C,IAAI,CAAC,aAAa,EAAE4B,WAAW,CAAC;IAC3D,MAAM;MAAEtE,KAAK;MAAE2C;IAAc,CAAC,GAAGF,QAAQ,CAACI,IAAI;IAE9C,IAAI7C,KAAK,IAAI2C,aAAa,EAAE;MAC1BW,cAAc,CAACtD,KAAK,EAAE2C,aAAa,CAAC;IACtC;IAEA,OAAOF,QAAQ;EACjB,CAAC,CAAC,OAAOf,KAAK,EAAE;IACd6B,OAAO,CAAC7B,KAAK,CAAC,cAAc,EAAEA,KAAK,CAAC;IACpC,MAAMA,KAAK;EACb;AACF,CAAC;AAED,MAAM6C,QAAQ,GAAG,MAAOC,QAAQ,IAAK;EACnC;EACA,OAAO7E,GAAG,CAACoD,QAAQ,CAACC,OAAO,CAACC,MAAM,CAAC,eAAe,CAAC;EAEnD,IAAI;IACF,MAAMR,QAAQ,GAAG,MAAM9C,GAAG,CAAC+C,IAAI,CAAC,gBAAgB,EAAE8B,QAAQ,CAAC;IAC3D,MAAM;MAAExE,KAAK;MAAE2C;IAAc,CAAC,GAAGF,QAAQ,CAACI,IAAI;IAE9C,IAAI7C,KAAK,IAAI2C,aAAa,EAAE;MAC1BW,cAAc,CAACtD,KAAK,EAAE2C,aAAa,CAAC;IACtC;IAEA,OAAOF,QAAQ;EACjB,CAAC,CAAC,OAAOf,KAAK,EAAE;IACd6B,OAAO,CAAC7B,KAAK,CAAC,qBAAqB,EAAEA,KAAK,CAAC;IAC3C,MAAMA,KAAK;EACb;AACF,CAAC;AAED,MAAM+C,MAAM,GAAG,MAAAA,CAAA,KAAY;EACzB,IAAI;IACF;IACA,MAAM9E,GAAG,CAAC+C,IAAI,CAAC,cAAc,CAAC;EAChC,CAAC,CAAC,OAAOhB,KAAK,EAAE;IACd;IACA6B,OAAO,CAACC,IAAI,CAAC,mCAAmC,EAAE9B,KAAK,CAAC;EAC1D,CAAC,SAAS;IACR;IACAiC,cAAc,CAAC,CAAC;EAClB;AACF,CAAC;AAED,MAAMe,cAAc,GAAGA,CAAA,KAAM;EAC3BrB,iBAAiB,CAAC,CAAC,CAAC,CAAC;EACrB,OAAO1D,GAAG,CAACgF,GAAG,CAAC,WAAW,CAAC;AAC7B,CAAC;;AAED;AACA,MAAMC,WAAW,GAAGA,CAACC,MAAM,GAAG,CAAC,CAAC,KAAK;EACnC,OAAOlF,GAAG,CAACgF,GAAG,CAAC,QAAQ,EAAE;IAAEE;EAAO,CAAC,CAAC;AACtC,CAAC;AAED,MAAMC,WAAW,GAAIC,MAAM,IAAK;EAC9B,OAAOpF,GAAG,CAACgF,GAAG,CAAC,UAAUI,MAAM,EAAE,CAAC;AACpC,CAAC;AAED,MAAMC,UAAU,GAAGA,CAACD,MAAM,EAAEP,QAAQ,KAAK;EACvC,OAAO7E,GAAG,CAACsF,GAAG,CAAC,UAAUF,MAAM,EAAE,EAAEP,QAAQ,CAAC;AAC9C,CAAC;AAED,MAAMU,UAAU,GAAIH,MAAM,IAAK;EAC7B,OAAOpF,GAAG,CAACwF,MAAM,CAAC,UAAUJ,MAAM,EAAE,CAAC;AACvC,CAAC;AAED,MAAMK,UAAU,GAAIZ,QAAQ,IAAK;EAC/B,OAAO7E,GAAG,CAAC+C,IAAI,CAAC,QAAQ,EAAE8B,QAAQ,CAAC;AACrC,CAAC;;AAED;AACA,MAAMa,uBAAuB,GAAGA,CAAA,KAAM;EACpC,OAAO1F,GAAG,CAACgF,GAAG,CAAC,sBAAsB,CAAC;AACxC,CAAC;AAED,MAAMW,mBAAmB,GAAGA,CAAA,KAAM;EAChC,OAAO3F,GAAG,CAACgF,GAAG,CAAC,mBAAmB,CAAC;AACrC,CAAC;AAED,MAAMY,kBAAkB,GAAIC,MAAM,IAAK;EACrC,OAAO7F,GAAG,CAAC+C,IAAI,CAAC,gBAAgB,EAAE;IAAE+C,OAAO,EAAED;EAAO,CAAC,CAAC;AACxD,CAAC;AAED,MAAME,kBAAkB,GAAIC,MAAM,IAAK;EACrC,OAAOhG,GAAG,CAACwF,MAAM,CAAC,mBAAmB,EAAE;IACrCtC,IAAI,EAAE;MAAE8C;IAAO;EACjB,CAAC,CAAC;AACJ,CAAC;AAED,MAAMC,iBAAiB,GAAGA,CAAA,KAAM;EAC9B,OAAOjG,GAAG,CAACgF,GAAG,CAAC,sBAAsB,CAAC;AACxC,CAAC;;AAED;AACA,MAAMkB,kBAAkB,GAAGA,CAAA,KAAM;EAC/B,OAAOlG,GAAG,CAAC+C,IAAI,CAAC,kBAAkB,CAAC;AACrC,CAAC;AAED,MAAMoD,cAAc,GAAGA,CAAA,KAAM;EAC3B,OAAOnG,GAAG,CAACgF,GAAG,CAAC,YAAY,CAAC;AAC9B,CAAC;AAED,MAAMoB,gBAAgB,GAAIC,UAAU,IAAK;EACvC,OAAOrG,GAAG,CAAC+C,IAAI,CAAC,gBAAgB,EAAE;IAAEuD,IAAI,EAAED;EAAW,CAAC,CAAC;AACzD,CAAC;AAED,MAAME,gBAAgB,GAAIC,MAAM,IAAK;EACnC,OAAOxG,GAAG,CAAC+C,IAAI,CAAC,kBAAkByD,MAAM,EAAE,CAAC;AAC7C,CAAC;;AAED;AACA,MAAMC,iBAAiB,GAAGA,CAAA,KAAM;EAC9B,OAAOzG,GAAG,CAACgF,GAAG,CAAC,cAAc,CAAC;AAChC,CAAC;AAED,MAAM0B,mBAAmB,GAAGA,CAACxB,MAAM,GAAG,CAAC,CAAC,KAAK;EAC3C,OAAOlF,GAAG,CAACgF,GAAG,CAAC,sBAAsB,EAAE;IAAEE;EAAO,CAAC,CAAC;AACpD,CAAC;AAED,MAAMyB,iBAAiB,GAAGA,CAACzB,MAAM,GAAG,CAAC,CAAC,KAAK;EACzC,OAAOlF,GAAG,CAACgF,GAAG,CAAC,cAAc,EAAE;IAAEE;EAAO,CAAC,CAAC;AAC5C,CAAC;AAED,MAAM0B,cAAc,GAAGA,CAACxB,MAAM,EAAExD,IAAI,KAAK;EACvC,OAAO5B,GAAG,CAACsF,GAAG,CAAC,gBAAgBF,MAAM,OAAO,EAAE;IAAExD;EAAK,CAAC,CAAC;AACzD,CAAC;;AAED;AACA,MAAMiF,YAAY,GAAGA,CAAA,KAAM;EACzB,OAAO7G,GAAG,CAACgF,GAAG,CAAC,YAAY,CAAC;AAC9B,CAAC;AAED,MAAM8B,cAAc,GAAGA,CAACC,SAAS,EAAEC,WAAW,KAAK;EACjD,OAAOhH,GAAG,CAAC+C,IAAI,CAAC,YAAY,EAAE;IAAEkE,UAAU,EAAEF,SAAS;IAAEG,YAAY,EAAEF;EAAY,CAAC,CAAC;AACrF,CAAC;AAED,MAAMG,mBAAmB,GAAIJ,SAAS,IAAK;EACzC,OAAO/G,GAAG,CAACwF,MAAM,CAAC,cAAcuB,SAAS,EAAE,CAAC;AAC9C,CAAC;;AAED;AACA,MAAMK,eAAe,GAAGA,CAAClC,MAAM,GAAG,CAAC,CAAC,KAAK;EACvC,OAAOlF,GAAG,CAACgF,GAAG,CAAC,UAAU,EAAE;IAAEE;EAAO,CAAC,CAAC;AACxC,CAAC;AAED,MAAMmC,iBAAiB,GAAGA,CAACN,SAAS,EAAEO,aAAa,EAAEC,eAAe,KAAK;EACvE,OAAOvH,GAAG,CAAC+C,IAAI,CAAC,UAAU,EAAE;IAC1BkE,UAAU,EAAEF,SAAS;IACrBS,cAAc,EAAEF,aAAa;IAC7BG,gBAAgB,EAAEF;EACpB,CAAC,CAAC;AACJ,CAAC;;AAED;AACA,MAAMG,eAAe,GAAGA,CAAA,KAAM;EAC5B,OAAO1H,GAAG,CAACgF,GAAG,CAAC,UAAU,CAAC;AAC5B,CAAC;AAED,MAAM2C,aAAa,GAAIC,WAAW,IAAK;EACrC,OAAO5H,GAAG,CAAC+C,IAAI,CAAC,UAAU,EAAE6E,WAAW,CAAC;AAC1C,CAAC;AAED,MAAMC,aAAa,GAAGA,CAACC,SAAS,EAAEF,WAAW,KAAK;EAChD,OAAO5H,GAAG,CAACsF,GAAG,CAAC,YAAYwC,SAAS,EAAE,EAAEF,WAAW,CAAC;AACtD,CAAC;AAED,MAAMG,aAAa,GAAID,SAAS,IAAK;EACnC,OAAO9H,GAAG,CAACwF,MAAM,CAAC,YAAYsC,SAAS,EAAE,CAAC;AAC5C,CAAC;;AAED;AACA,MAAME,cAAc,GAAGA,CAACC,eAAe,EAAEC,WAAW,KAAK;EACvD,OAAOlI,GAAG,CAAC+C,IAAI,CAAC,oBAAoB,EAAE;IAAEoF,gBAAgB,EAAEF,eAAe;IAAEG,YAAY,EAAEF;EAAY,CAAC,CAAC;AACzG,CAAC;AAED,MAAMG,sBAAsB,GAAGA,CAACjD,MAAM,EAAE8C,WAAW,KAAK;EACtD,OAAOlI,GAAG,CAAC+C,IAAI,CAAC,gBAAgBqC,MAAM,iBAAiB,EAAE;IAAEgD,YAAY,EAAEF;EAAY,CAAC,CAAC;AACzF,CAAC;AAED,MAAMI,oBAAoB,GAAG,MAAOC,KAAK,IAAK;EAC5C,OAAOvI,GAAG,CAAC+C,IAAI,CAAC,uBAAuB,EAAE;IAAEwF;EAAM,CAAC,CAAC;AACrD,CAAC;AAED,MAAMC,aAAa,GAAG,MAAAA,CAAOnI,KAAK,EAAE6H,WAAW,KAAK;EAClD,OAAOlI,GAAG,CAAC+C,IAAI,CAAC,sBAAsB,EAAE;IACtC1C,KAAK;IACL+H,YAAY,EAAEF;EAChB,CAAC,CAAC;AACJ,CAAC;AAED,SACElI,GAAG,IAAIyI,OAAO,EACd/D,KAAK,EACLE,QAAQ,EACRE,MAAM,EACNC,cAAc,EACdE,WAAW,EACXE,WAAW,EACXE,UAAU,EACVE,UAAU,EACVE,UAAU,EACVC,uBAAuB,EACvBC,mBAAmB,EACnBC,kBAAkB,EAClBG,kBAAkB,EAClBE,iBAAiB,EACjBC,kBAAkB,EAClBC,cAAc,EACdC,gBAAgB,EAChBG,gBAAgB,EAChBE,iBAAiB,EACjBC,mBAAmB,EACnBC,iBAAiB,EACjBC,cAAc,EACdC,YAAY,EACZC,cAAc,EACdK,mBAAmB,EACnBC,eAAe,EACfC,iBAAiB,EACjBK,eAAe,EACfC,aAAa,EACbE,aAAa,EACbE,aAAa,EACbC,cAAc,EACdK,sBAAsB,EACtBC,oBAAoB,EACpBE,aAAa,EACbpI,UAAU,EACVsD,iBAAiB,EACjBC,cAAc,EACdK,cAAc,EACd3B,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}