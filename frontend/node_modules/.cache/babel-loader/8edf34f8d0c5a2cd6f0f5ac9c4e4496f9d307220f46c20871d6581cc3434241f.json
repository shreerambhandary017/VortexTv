{"ast":null,"code":"var _jsxFileName = \"D:\\\\Movie\\\\frontend\\\\src\\\\context\\\\AuthContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport axios from 'axios';\nimport jwtDecode from 'jwt-decode';\nimport { setupTokenRefresh, storeAuthToken, clearAuthToken, getCurrentUser, register as registerApi, login as loginApi, checkSubscription as checkSubscriptionApi, generateAccessCode as generateAccessCodeApi, redeemAccessCode as redeemAccessCodeApi, getAccessCodes as getAccessCodesApi } from '../api/backendApi';\n\n// Create auth context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const AuthContext = /*#__PURE__*/createContext();\n\n// Provider component\nexport const AuthProvider = ({\n  children\n}) => {\n  _s();\n  const [user, setUser] = useState(null);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [success, setSuccess] = useState(null);\n  const navigate = useNavigate();\n\n  // Check if user is already logged in on mount\n  useEffect(() => {\n    console.log(\"AuthContext mounted - checking login status\");\n    checkUserLoggedIn();\n\n    // Listen for storage events (e.g., token changes in other tabs)\n    const handleStorageChange = e => {\n      if (e.key === 'token') {\n        if (e.newValue) {\n          console.log('Token updated in another tab - refreshing auth state');\n          checkUserLoggedIn();\n        } else {\n          console.log('Token removed in another tab - logging out');\n          handleLogout();\n        }\n      }\n    };\n\n    // Set up token refresh timer\n    let refreshTimer = null;\n    const setupTokenRefresh = () => {\n      // Clear existing timer if any\n      if (refreshTimer) {\n        clearTimeout(refreshTimer);\n      }\n      const token = localStorage.getItem('token');\n      if (!token) return;\n      try {\n        // Decode token to check expiration\n        const decoded = jwtDecode(token);\n\n        // Calculate time until token expires (in milliseconds)\n        // Refresh when 90% of the token's lifetime has passed\n        const currentTime = Date.now() / 1000;\n        const expiryTime = decoded.exp;\n        const timeUntilExpiry = (expiryTime - currentTime) * 1000;\n        const refreshTime = timeUntilExpiry * 0.9; // Refresh at 90% of lifetime\n\n        console.log(`Token expires in ${Math.round(timeUntilExpiry / 1000 / 60)} minutes, will refresh in ${Math.round(refreshTime / 1000 / 60)} minutes`);\n        if (timeUntilExpiry > 0) {\n          refreshTimer = setTimeout(() => {\n            console.log('Token refresh timer triggered');\n            refreshAuthToken();\n          }, refreshTime);\n        }\n      } catch (error) {\n        console.error('Error setting up token refresh:', error);\n      }\n    };\n\n    // Initial setup of refresh timer\n    setupTokenRefresh();\n    window.addEventListener('storage', handleStorageChange);\n    return () => {\n      window.removeEventListener('storage', handleStorageChange);\n      if (refreshTimer) clearTimeout(refreshTimer);\n    };\n  }, []);\n\n  // Handle logout process\n  const handleLogout = () => {\n    setUser(null);\n    setIsAuthenticated(false);\n    clearAuthToken();\n  };\n\n  // Refresh the auth token before it expires\n  const refreshAuthToken = async () => {\n    console.log('Attempting to refresh auth token');\n    try {\n      // Only attempt refresh if we're authenticated\n      if (!isAuthenticated) {\n        console.log('Not authenticated, skipping token refresh');\n        return false;\n      }\n\n      // Call the refresh token endpoint\n      const response = await axios.post(`${axios.defaults.baseURL}/auth/refresh-token`, {}, {\n        headers: {\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\n        }\n      });\n      if (response.data && response.data.token) {\n        console.log('Token refreshed successfully');\n        storeAuthToken(response.data.token);\n\n        // Reset refresh timer\n        const decoded = jwtDecode(response.data.token);\n        const currentTime = Date.now() / 1000;\n        const expiryTime = decoded.exp;\n        const timeUntilExpiry = (expiryTime - currentTime) * 1000;\n        console.log(`New token expires in ${Math.round(timeUntilExpiry / 1000 / 60)} minutes`);\n        return true;\n      } else {\n        console.error('Token refresh failed - invalid response');\n        return false;\n      }\n    } catch (error) {\n      console.error('Error refreshing token:', error);\n\n      // If we get a 401 on token refresh, the session is truly expired\n      if (error.response && error.response.status === 401) {\n        console.log('Session expired during token refresh attempt');\n        handleLogout();\n      }\n      return false;\n    }\n  };\n\n  // Check if token exists and is valid\n  const checkUserLoggedIn = async () => {\n    setIsLoading(true);\n    console.log(\"Checking if user is logged in...\");\n    const token = localStorage.getItem('token');\n    if (!token) {\n      console.log(\"No token found - user is not logged in\");\n      setIsLoading(false);\n      return;\n    }\n    try {\n      // Check if token is expired\n      const decoded = jwtDecode(token);\n      const currentTime = Date.now() / 1000;\n      if (decoded.exp < currentTime) {\n        console.log(\"Token expired - logging out\");\n        clearAuthToken();\n        setIsAuthenticated(false);\n        setUser(null);\n        setIsLoading(false);\n        return;\n      }\n      console.log(\"Token is valid - refreshing auth state\");\n\n      // Ensure token is set in headers\n      setupTokenRefresh();\n\n      // First check if we have cached subscription data\n      let cachedSubscriptionData = null;\n      try {\n        const cachedData = localStorage.getItem('vortextv_subscription_data');\n        if (cachedData) {\n          cachedSubscriptionData = JSON.parse(cachedData);\n          console.log(\"Found cached subscription data:\", cachedSubscriptionData);\n        }\n      } catch (cacheError) {\n        console.error(\"Error reading cached subscription data:\", cacheError);\n      }\n      try {\n        // Get current user data\n        console.log(\"Fetching current user data\");\n        const response = await getCurrentUser();\n        console.log(\"User data retrieved successfully\", response.data);\n\n        // Merge subscription data from cache into user object if available\n        let userData = response.data;\n        if (cachedSubscriptionData) {\n          userData = {\n            ...userData,\n            hasSubscription: cachedSubscriptionData.hasSubscription,\n            hasAccessCode: cachedSubscriptionData.hasAccessCode,\n            subscription: cachedSubscriptionData.subscription,\n            subscriptionPlan: cachedSubscriptionData.subscriptionPlan,\n            subscriptionStatus: cachedSubscriptionData.status,\n            subscriptionExpiry: cachedSubscriptionData.expiryDate,\n            generatedCodes: cachedSubscriptionData.generatedCodes || 0,\n            maxAllowedCodes: cachedSubscriptionData.maxAllowedCodes || 0,\n            remainingCodes: cachedSubscriptionData.remainingCodes || 0,\n            accessCodeDetails: cachedSubscriptionData.accessCodeDetails\n          };\n          console.log(\"Merged cached subscription data with user data\");\n        }\n        setUser(userData);\n        setIsAuthenticated(true);\n\n        // Immediately after auth is established, trigger a subscription check in background\n        // This will update the cached data with fresh data from the server\n        setTimeout(() => {\n          console.log(\"Performing background subscription check after login\");\n          checkSubscription().then(() => {\n            console.log(\"Background subscription check completed\");\n          }).catch(err => {\n            console.error(\"Background subscription check failed:\", err);\n          });\n        }, 200);\n      } catch (error) {\n        console.error('Error fetching user data:', error);\n\n        // If we can't get user data but have a valid token,\n        // try to extract basic info from the token itself\n        try {\n          const tokenData = {\n            user_id: decoded.sub,\n            role: decoded.role\n          };\n          console.log(\"Using token data as fallback:\", tokenData);\n\n          // Merge with cached subscription data if available\n          if (cachedSubscriptionData) {\n            Object.assign(tokenData, {\n              hasSubscription: cachedSubscriptionData.hasSubscription,\n              hasAccessCode: cachedSubscriptionData.hasAccessCode,\n              subscription: cachedSubscriptionData.subscription,\n              subscriptionPlan: cachedSubscriptionData.subscriptionPlan,\n              subscriptionStatus: cachedSubscriptionData.status,\n              subscriptionExpiry: cachedSubscriptionData.expiryDate,\n              generatedCodes: cachedSubscriptionData.generatedCodes || 0,\n              maxAllowedCodes: cachedSubscriptionData.maxAllowedCodes || 0,\n              remainingCodes: cachedSubscriptionData.remainingCodes || 0,\n              accessCodeDetails: cachedSubscriptionData.accessCodeDetails\n            });\n            console.log(\"Merged cached subscription data with token data\");\n          }\n          setUser(tokenData);\n          setIsAuthenticated(true);\n\n          // Try to get fresh subscription data\n          setTimeout(() => checkSubscription(), 300);\n        } catch (tokenError) {\n          console.error('Failed to extract user data from token:', tokenError);\n          clearAuthToken();\n          setUser(null);\n          setIsAuthenticated(false);\n        }\n      }\n    } catch (error) {\n      console.error('Error decoding/validating token:', error);\n      clearAuthToken();\n      setUser(null);\n      setIsAuthenticated(false);\n    }\n    setIsLoading(false);\n  };\n\n  // Register user\n  const register = async formData => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      console.log('Attempting to register with:', {\n        username: formData.username,\n        email: formData.email,\n        password: formData.password ? '*****' : 'empty'\n      });\n      const response = await registerApi(formData);\n      console.log('Registration response:', response.data);\n      const token = response.data.token;\n      console.log('Token received:', token ? `${token.substring(0, 15)}...` : 'No token');\n      if (!token) {\n        setError('Registration successful but no authentication token received');\n        setIsLoading(false);\n        return false;\n      }\n\n      // Store token consistently\n      storeAuthToken(token);\n\n      // Set user data from the response\n      const userData = {\n        user_id: response.data.user_id,\n        username: response.data.username || formData.username,\n        email: response.data.email || formData.email,\n        role: response.data.role || 'user' // Default role for new registrations\n      };\n      setUser(userData);\n      setIsAuthenticated(true);\n      navigate('/subscriptions');\n      return true;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error('Registration error:', error);\n      setError(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Registration failed');\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Login user\n  const login = async credentials => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      console.log('Attempting login with credentials:', {\n        username: credentials.username,\n        password: credentials.password ? '*****' : 'empty'\n      });\n\n      // Clear any existing tokens before login attempt\n      clearAuthToken();\n\n      // Use backendApi which has token interceptor setup\n      const response = await loginApi(credentials);\n      console.log('Login response received:', {\n        status: response.status\n      });\n      const token = response.data.token;\n      console.log('Token received:', token ? `${token.substring(0, 15)}...` : 'No token');\n      if (!token) {\n        console.error('No token received in login response');\n        setError('Authentication failed: No token received');\n        setIsLoading(false);\n        return false;\n      }\n\n      // Store token consistently\n      storeAuthToken(token);\n      try {\n        // Get current user data after login with proper authorization header\n        console.log('Fetching user data after login');\n        const userResponse = await getCurrentUser();\n        console.log('User data received:', userResponse.data);\n        const userData = userResponse.data;\n        setUser(userData);\n        setIsAuthenticated(true);\n\n        // Redirect based on user role\n        if (userData.role === 'admin' || userData.role === 'superadmin') {\n          navigate('/admin');\n        } else {\n          navigate('/browse');\n        }\n        return true;\n      } catch (userError) {\n        console.error('Error fetching user data after login:', userError);\n\n        // Even if user fetch fails, we're still logged in with a token\n        // Set minimal user data based on the login response\n        const minimalUserData = {\n          user_id: response.data.user_id,\n          username: response.data.username,\n          email: response.data.email,\n          role: response.data.role\n        };\n        console.log('Setting minimal user data:', minimalUserData);\n        setUser(minimalUserData);\n        setIsAuthenticated(true);\n\n        // Redirect based on role from login response\n        if (response.data.role === 'admin' || response.data.role === 'superadmin') {\n          navigate('/admin');\n        } else {\n          navigate('/browse');\n        }\n        return true;\n      }\n    } catch (error) {\n      console.error('Login error:', error);\n\n      // Enhanced error logging\n      if (error.response) {\n        console.error('Error response data:', error.response.data);\n        console.error('Error response status:', error.response.status);\n        console.error('Error response headers:', error.response.headers);\n        setError(error.response.data.message || 'Login failed');\n      } else if (error.request) {\n        console.error('Error request:', error.request);\n        setError('No response received from server. Please try again later.');\n      } else {\n        console.error('Error message:', error.message);\n        setError(error.message || 'Login failed');\n      }\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Logout user\n  const logout = () => {\n    handleLogout();\n    navigate('/login');\n  };\n\n  // Check if user has active subscription\n  const checkSubscription = async () => {\n    if (!isAuthenticated) {\n      console.log('Not authenticated, cannot check subscription');\n      return false;\n    }\n\n    // Add a retry mechanism for reliability\n    let retries = 2;\n    let success = false;\n    let finalResponse = null;\n    while (retries >= 0 && !success) {\n      try {\n        console.log(`Checking subscription (${2 - retries}/2 attempt)`);\n        const response = await checkSubscriptionApi();\n        success = true;\n        finalResponse = response;\n        console.log('Subscription check successful:', response.data);\n      } catch (error) {\n        console.error(`Attempt ${2 - retries}/2 failed:`, error);\n        retries--;\n        if (retries >= 0) {\n          // Wait before retrying (500ms, then 1000ms)\n          await new Promise(resolve => setTimeout(resolve, 500 * (3 - retries)));\n        }\n      }\n    }\n    if (!success || !finalResponse) {\n      console.error('All subscription check attempts failed');\n\n      // Try to use cached data if available\n      const cachedSubscription = localStorage.getItem('vortextv_subscription_data');\n      if (cachedSubscription) {\n        try {\n          const parsedData = JSON.parse(cachedSubscription);\n          console.log('Using cached subscription data:', parsedData);\n\n          // Update user with cached data\n          setUser(prevUser => ({\n            ...prevUser,\n            hasSubscription: parsedData.hasSubscription,\n            hasAccessCode: parsedData.hasAccessCode,\n            subscription: parsedData.subscription,\n            subscriptionPlan: parsedData.subscriptionPlan,\n            subscriptionStatus: parsedData.status,\n            subscriptionExpiry: parsedData.expiryDate,\n            generatedCodes: parsedData.generatedCodes || 0,\n            maxAllowedCodes: parsedData.maxAllowedCodes || 0,\n            remainingCodes: parsedData.remainingCodes || 0,\n            accessCodeDetails: parsedData.accessCodeDetails\n          }));\n          return parsedData.hasSubscription && parsedData.status === 'active';\n        } catch (e) {\n          console.error('Error parsing cached subscription data:', e);\n        }\n      }\n      return false;\n    }\n    const data = finalResponse.data;\n\n    // Cache the subscription data for later use if needed\n    localStorage.setItem('vortextv_subscription_data', JSON.stringify(data));\n\n    // Update user data with subscription info\n    setUser(prevUser => ({\n      ...prevUser,\n      hasSubscription: data.hasSubscription,\n      hasAccessCode: data.hasAccessCode,\n      subscription: data.subscription,\n      // Add more detailed subscription data\n      subscriptionPlan: data.subscriptionPlan,\n      subscriptionStatus: data.status,\n      subscriptionExpiry: data.expiryDate,\n      generatedCodes: data.generatedCodes || 0,\n      maxAllowedCodes: data.maxAllowedCodes || 0,\n      remainingCodes: data.remainingCodes || 0,\n      accessCodeDetails: data.accessCodeDetails\n    }));\n\n    // Check if subscription is active (not expired)\n    const isActive = data.hasSubscription && data.status === 'active' && new Date(data.expiryDate) > new Date();\n\n    // Or check if access code is valid\n    const hasValidCode = data.hasAccessCode && data.accessCodeDetails && new Date(data.accessCodeDetails.expiryDate) > new Date();\n    const result = isActive || hasValidCode;\n    console.log(`Subscription check result: ${result ? 'Active' : 'Inactive'}`);\n    return result;\n  };\n\n  // Generate an access code for the user's subscription\n  const generateAccessCode = async () => {\n    setIsLoading(true);\n    console.log('AuthContext: Starting access code generation');\n\n    // Make sure subscription data is up-to-date before generating\n    try {\n      if (!isAuthenticated) {\n        console.error('AuthContext: Cannot generate code - not authenticated');\n        setError('Authentication required');\n        return {\n          success: false,\n          error: 'Authentication required'\n        };\n      }\n\n      // Check subscription status directly from user object\n      if (!user) {\n        console.error('AuthContext: Cannot generate code - no user data');\n        setError('User data unavailable');\n        return {\n          success: false,\n          error: 'User data unavailable'\n        };\n      }\n      if (!user.hasSubscription) {\n        console.error('AuthContext: Cannot generate code - no active subscription');\n        setError('No active subscription found');\n        return {\n          success: false,\n          error: 'No active subscription found'\n        };\n      }\n\n      // Debug the request before sending\n      console.log('AuthContext: Making API call to generate access code');\n\n      // Make the API request with specific headers and timeout\n      const response = await generateAccessCodeApi();\n      console.log('AuthContext: Access code API response:', response.data);\n      if (response.data && response.data.success) {\n        const successMsg = `Access code generated: ${response.data.code}`;\n        console.log('AuthContext: ' + successMsg);\n        setSuccess(successMsg);\n\n        // Update subscription data in user context\n        setUser(prevUser => ({\n          ...prevUser,\n          remainingCodes: response.data.remainingCodes,\n          generatedCodes: response.data.generatedCodes\n        }));\n\n        // Return the generated code data\n        return response.data;\n      } else {\n        var _response$data;\n        const errorMsg = ((_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.error) || 'Failed to generate access code';\n        console.error('AuthContext: Access code generation failed:', errorMsg);\n        setError(errorMsg);\n        return {\n          success: false,\n          error: errorMsg\n        };\n      }\n    } catch (err) {\n      var _err$response, _err$response$data;\n      console.error('AuthContext: Error generating access code:', err);\n      const errorMsg = ((_err$response = err.response) === null || _err$response === void 0 ? void 0 : (_err$response$data = _err$response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.error) || err.message || 'Failed to generate access code';\n      setError(errorMsg);\n      return {\n        success: false,\n        error: errorMsg,\n        details: err.toString()\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Redeem an access code\n  const redeemAccessCode = async code => {\n    setIsLoading(true);\n    try {\n      if (!isAuthenticated) {\n        setError('Authentication required');\n        return false;\n      }\n      const response = await redeemAccessCodeApi(code);\n      if (response.data && response.data.success) {\n        setSuccess('Access code redeemed successfully');\n        // Update user's subscription status after redemption\n        await checkSubscription();\n        return response.data.accessCodeDetails;\n      } else {\n        setError(response.data.error || 'Failed to redeem access code');\n        return null;\n      }\n    } catch (err) {\n      var _err$response2, _err$response2$data;\n      console.error('Error redeeming access code:', err);\n      setError(((_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : (_err$response2$data = _err$response2.data) === null || _err$response2$data === void 0 ? void 0 : _err$response2$data.error) || 'Failed to redeem access code');\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const getUserAccessCodes = async () => {\n    // Guard clause - check if authenticated and has subscription\n    if (!isAuthenticated) {\n      console.log('Not authenticated, cannot get access codes');\n      return {\n        success: false,\n        codes: [],\n        error: 'Authentication required'\n      };\n    }\n    if (!user || !user.hasSubscription) {\n      console.log('User has no subscription, cannot get access codes');\n      return {\n        success: false,\n        codes: [],\n        error: 'No active subscription'\n      };\n    }\n    try {\n      console.log('Fetching access codes from API');\n      const response = await getAccessCodesApi();\n\n      // Validate the response structure\n      if (response && response.data) {\n        // Check if codes array exists, if not default to empty array\n        const codes = Array.isArray(response.data.codes) ? response.data.codes : Array.isArray(response.data) ? response.data : [];\n        console.log(`Retrieved ${codes.length} access codes`);\n        return {\n          success: true,\n          codes: codes\n        };\n      } else {\n        console.error('Invalid response format from access codes API');\n        return {\n          success: false,\n          codes: [],\n          error: 'Invalid response format'\n        };\n      }\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      console.error('Error fetching access codes:', error);\n      return {\n        success: false,\n        codes: [],\n        error: ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || error.message || 'Error fetching access codes'\n      };\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: {\n      user,\n      isAuthenticated,\n      isLoading,\n      error,\n      success,\n      register,\n      login,\n      logout,\n      checkSubscription,\n      generateAccessCode,\n      redeemAccessCode,\n      getUserAccessCodes,\n      refreshAuth: checkUserLoggedIn // Expose this to allow manual refresh\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 666,\n    columnNumber: 5\n  }, this);\n};\n_s(AuthProvider, \"m8OJeA/thn820aF3Qgjie0Y2NI4=\", false, function () {\n  return [useNavigate];\n});\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useNavigate","axios","jwtDecode","setupTokenRefresh","storeAuthToken","clearAuthToken","getCurrentUser","register","registerApi","login","loginApi","checkSubscription","checkSubscriptionApi","generateAccessCode","generateAccessCodeApi","redeemAccessCode","redeemAccessCodeApi","getAccessCodes","getAccessCodesApi","jsxDEV","_jsxDEV","AuthContext","AuthProvider","children","_s","user","setUser","isAuthenticated","setIsAuthenticated","isLoading","setIsLoading","error","setError","success","setSuccess","navigate","console","log","checkUserLoggedIn","handleStorageChange","e","key","newValue","handleLogout","refreshTimer","clearTimeout","token","localStorage","getItem","decoded","currentTime","Date","now","expiryTime","exp","timeUntilExpiry","refreshTime","Math","round","setTimeout","refreshAuthToken","window","addEventListener","removeEventListener","response","post","defaults","baseURL","headers","data","status","cachedSubscriptionData","cachedData","JSON","parse","cacheError","userData","hasSubscription","hasAccessCode","subscription","subscriptionPlan","subscriptionStatus","subscriptionExpiry","expiryDate","generatedCodes","maxAllowedCodes","remainingCodes","accessCodeDetails","then","catch","err","tokenData","user_id","sub","role","Object","assign","tokenError","formData","username","email","password","substring","_error$response","_error$response$data","message","credentials","userResponse","userError","minimalUserData","request","logout","retries","finalResponse","Promise","resolve","cachedSubscription","parsedData","prevUser","setItem","stringify","isActive","hasValidCode","result","successMsg","code","_response$data","errorMsg","_err$response","_err$response$data","details","toString","_err$response2","_err$response2$data","getUserAccessCodes","codes","Array","isArray","length","_error$response2","_error$response2$data","Provider","value","refreshAuth","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Movie/frontend/src/context/AuthContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport axios from 'axios';\nimport jwtDecode from 'jwt-decode';\nimport { setupTokenRefresh, storeAuthToken, clearAuthToken, getCurrentUser, register as registerApi, login as loginApi, checkSubscription as checkSubscriptionApi, generateAccessCode as generateAccessCodeApi, redeemAccessCode as redeemAccessCodeApi, getAccessCodes as getAccessCodesApi } from '../api/backendApi';\n\n// Create auth context\nexport const AuthContext = createContext();\n\n// Provider component\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [success, setSuccess] = useState(null);\n  const navigate = useNavigate();\n\n  // Check if user is already logged in on mount\n  useEffect(() => {\n    console.log(\"AuthContext mounted - checking login status\");\n    checkUserLoggedIn();\n    \n    // Listen for storage events (e.g., token changes in other tabs)\n    const handleStorageChange = (e) => {\n      if (e.key === 'token') {\n        if (e.newValue) {\n          console.log('Token updated in another tab - refreshing auth state');\n          checkUserLoggedIn();\n        } else {\n          console.log('Token removed in another tab - logging out');\n          handleLogout();\n        }\n      }\n    };\n    \n    // Set up token refresh timer\n    let refreshTimer = null;\n    const setupTokenRefresh = () => {\n      // Clear existing timer if any\n      if (refreshTimer) {\n        clearTimeout(refreshTimer);\n      }\n      \n      const token = localStorage.getItem('token');\n      if (!token) return;\n      \n      try {\n        // Decode token to check expiration\n        const decoded = jwtDecode(token);\n        \n        // Calculate time until token expires (in milliseconds)\n        // Refresh when 90% of the token's lifetime has passed\n        const currentTime = Date.now() / 1000;\n        const expiryTime = decoded.exp;\n        const timeUntilExpiry = (expiryTime - currentTime) * 1000;\n        const refreshTime = timeUntilExpiry * 0.9; // Refresh at 90% of lifetime\n        \n        console.log(`Token expires in ${Math.round(timeUntilExpiry/1000/60)} minutes, will refresh in ${Math.round(refreshTime/1000/60)} minutes`);\n        \n        if (timeUntilExpiry > 0) {\n          refreshTimer = setTimeout(() => {\n            console.log('Token refresh timer triggered');\n            refreshAuthToken();\n          }, refreshTime);\n        }\n      } catch (error) {\n        console.error('Error setting up token refresh:', error);\n      }\n    };\n    \n    // Initial setup of refresh timer\n    setupTokenRefresh();\n    \n    window.addEventListener('storage', handleStorageChange);\n    return () => {\n      window.removeEventListener('storage', handleStorageChange);\n      if (refreshTimer) clearTimeout(refreshTimer);\n    };\n  }, []);\n\n  // Handle logout process\n  const handleLogout = () => {\n    setUser(null);\n    setIsAuthenticated(false);\n    clearAuthToken();\n  };\n  \n  // Refresh the auth token before it expires\n  const refreshAuthToken = async () => {\n    console.log('Attempting to refresh auth token');\n    try {\n      // Only attempt refresh if we're authenticated\n      if (!isAuthenticated) {\n        console.log('Not authenticated, skipping token refresh');\n        return false;\n      }\n      \n      // Call the refresh token endpoint\n      const response = await axios.post(`${axios.defaults.baseURL}/auth/refresh-token`, {}, {\n        headers: {\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\n        }\n      });\n      \n      if (response.data && response.data.token) {\n        console.log('Token refreshed successfully');\n        storeAuthToken(response.data.token);\n        \n        // Reset refresh timer\n        const decoded = jwtDecode(response.data.token);\n        const currentTime = Date.now() / 1000;\n        const expiryTime = decoded.exp;\n        const timeUntilExpiry = (expiryTime - currentTime) * 1000;\n        console.log(`New token expires in ${Math.round(timeUntilExpiry/1000/60)} minutes`);\n        \n        return true;\n      } else {\n        console.error('Token refresh failed - invalid response');\n        return false;\n      }\n    } catch (error) {\n      console.error('Error refreshing token:', error);\n      \n      // If we get a 401 on token refresh, the session is truly expired\n      if (error.response && error.response.status === 401) {\n        console.log('Session expired during token refresh attempt');\n        handleLogout();\n      }\n      \n      return false;\n    }\n  };\n\n  // Check if token exists and is valid\n  const checkUserLoggedIn = async () => {\n    setIsLoading(true);\n    console.log(\"Checking if user is logged in...\");\n    \n    const token = localStorage.getItem('token');\n    \n    if (!token) {\n      console.log(\"No token found - user is not logged in\");\n      setIsLoading(false);\n      return;\n    }\n    \n    try {\n      // Check if token is expired\n      const decoded = jwtDecode(token);\n      const currentTime = Date.now() / 1000;\n      \n      if (decoded.exp < currentTime) {\n        console.log(\"Token expired - logging out\");\n        clearAuthToken();\n        setIsAuthenticated(false);\n        setUser(null);\n        setIsLoading(false);\n        return;\n      }\n      \n      console.log(\"Token is valid - refreshing auth state\");\n      \n      // Ensure token is set in headers\n      setupTokenRefresh();\n      \n      // First check if we have cached subscription data\n      let cachedSubscriptionData = null;\n      try {\n        const cachedData = localStorage.getItem('vortextv_subscription_data');\n        if (cachedData) {\n          cachedSubscriptionData = JSON.parse(cachedData);\n          console.log(\"Found cached subscription data:\", cachedSubscriptionData);\n        }\n      } catch (cacheError) {\n        console.error(\"Error reading cached subscription data:\", cacheError);\n      }\n      \n      try {\n        // Get current user data\n        console.log(\"Fetching current user data\");\n        const response = await getCurrentUser();\n        console.log(\"User data retrieved successfully\", response.data);\n        \n        // Merge subscription data from cache into user object if available\n        let userData = response.data;\n        if (cachedSubscriptionData) {\n          userData = {\n            ...userData,\n            hasSubscription: cachedSubscriptionData.hasSubscription,\n            hasAccessCode: cachedSubscriptionData.hasAccessCode,\n            subscription: cachedSubscriptionData.subscription,\n            subscriptionPlan: cachedSubscriptionData.subscriptionPlan,\n            subscriptionStatus: cachedSubscriptionData.status,\n            subscriptionExpiry: cachedSubscriptionData.expiryDate,\n            generatedCodes: cachedSubscriptionData.generatedCodes || 0,\n            maxAllowedCodes: cachedSubscriptionData.maxAllowedCodes || 0,\n            remainingCodes: cachedSubscriptionData.remainingCodes || 0,\n            accessCodeDetails: cachedSubscriptionData.accessCodeDetails\n          };\n          console.log(\"Merged cached subscription data with user data\");\n        }\n        \n        setUser(userData);\n        setIsAuthenticated(true);\n        \n        // Immediately after auth is established, trigger a subscription check in background\n        // This will update the cached data with fresh data from the server\n        setTimeout(() => {\n          console.log(\"Performing background subscription check after login\");\n          checkSubscription().then(() => {\n            console.log(\"Background subscription check completed\");\n          }).catch(err => {\n            console.error(\"Background subscription check failed:\", err);\n          });\n        }, 200);\n      } catch (error) {\n        console.error('Error fetching user data:', error);\n        \n        // If we can't get user data but have a valid token,\n        // try to extract basic info from the token itself\n        try {\n          const tokenData = {\n            user_id: decoded.sub,\n            role: decoded.role\n          };\n          console.log(\"Using token data as fallback:\", tokenData);\n          \n          // Merge with cached subscription data if available\n          if (cachedSubscriptionData) {\n            Object.assign(tokenData, {\n              hasSubscription: cachedSubscriptionData.hasSubscription,\n              hasAccessCode: cachedSubscriptionData.hasAccessCode,\n              subscription: cachedSubscriptionData.subscription,\n              subscriptionPlan: cachedSubscriptionData.subscriptionPlan,\n              subscriptionStatus: cachedSubscriptionData.status,\n              subscriptionExpiry: cachedSubscriptionData.expiryDate,\n              generatedCodes: cachedSubscriptionData.generatedCodes || 0,\n              maxAllowedCodes: cachedSubscriptionData.maxAllowedCodes || 0,\n              remainingCodes: cachedSubscriptionData.remainingCodes || 0,\n              accessCodeDetails: cachedSubscriptionData.accessCodeDetails\n            });\n            console.log(\"Merged cached subscription data with token data\");\n          }\n          \n          setUser(tokenData);\n          setIsAuthenticated(true);\n          \n          // Try to get fresh subscription data\n          setTimeout(() => checkSubscription(), 300);\n        } catch (tokenError) {\n          console.error('Failed to extract user data from token:', tokenError);\n          clearAuthToken();\n          setUser(null);\n          setIsAuthenticated(false);\n        }\n      }\n    } catch (error) {\n      console.error('Error decoding/validating token:', error);\n      clearAuthToken();\n      setUser(null);\n      setIsAuthenticated(false);\n    }\n    \n    setIsLoading(false);\n  };\n\n  // Register user\n  const register = async (formData) => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      console.log('Attempting to register with:', { \n        username: formData.username,\n        email: formData.email,\n        password: formData.password ? '*****' : 'empty'\n      });\n      \n      const response = await registerApi(formData);\n      console.log('Registration response:', response.data);\n      \n      const token = response.data.token;\n      console.log('Token received:', token ? `${token.substring(0, 15)}...` : 'No token');\n      \n      if (!token) {\n        setError('Registration successful but no authentication token received');\n        setIsLoading(false);\n        return false;\n      }\n      \n      // Store token consistently\n      storeAuthToken(token);\n      \n      // Set user data from the response\n      const userData = {\n        user_id: response.data.user_id,\n        username: response.data.username || formData.username,\n        email: response.data.email || formData.email,\n        role: response.data.role || 'user' // Default role for new registrations\n      };\n      \n      setUser(userData);\n      setIsAuthenticated(true);\n      \n      navigate('/subscriptions');\n      return true;\n    } catch (error) {\n      console.error('Registration error:', error);\n      setError(error.response?.data?.message || 'Registration failed');\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Login user\n  const login = async (credentials) => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      console.log('Attempting login with credentials:', { \n        username: credentials.username, \n        password: credentials.password ? '*****' : 'empty' \n      });\n      \n      // Clear any existing tokens before login attempt\n      clearAuthToken();\n      \n      // Use backendApi which has token interceptor setup\n      const response = await loginApi(credentials);\n      console.log('Login response received:', { status: response.status });\n      \n      const token = response.data.token;\n      console.log('Token received:', token ? `${token.substring(0, 15)}...` : 'No token');\n      \n      if (!token) {\n        console.error('No token received in login response');\n        setError('Authentication failed: No token received');\n        setIsLoading(false);\n        return false;\n      }\n      \n      // Store token consistently\n      storeAuthToken(token);\n      \n      try {\n        // Get current user data after login with proper authorization header\n        console.log('Fetching user data after login');\n        const userResponse = await getCurrentUser();\n        \n        console.log('User data received:', userResponse.data);\n        const userData = userResponse.data;\n        setUser(userData);\n        setIsAuthenticated(true);\n        \n        // Redirect based on user role\n        if (userData.role === 'admin' || userData.role === 'superadmin') {\n          navigate('/admin');\n        } else {\n          navigate('/browse');\n        }\n        \n        return true;\n      } catch (userError) {\n        console.error('Error fetching user data after login:', userError);\n        \n        // Even if user fetch fails, we're still logged in with a token\n        // Set minimal user data based on the login response\n        const minimalUserData = {\n          user_id: response.data.user_id,\n          username: response.data.username,\n          email: response.data.email,\n          role: response.data.role\n        };\n        \n        console.log('Setting minimal user data:', minimalUserData);\n        setUser(minimalUserData);\n        setIsAuthenticated(true);\n        \n        // Redirect based on role from login response\n        if (response.data.role === 'admin' || response.data.role === 'superadmin') {\n          navigate('/admin');\n        } else {\n          navigate('/browse');\n        }\n        \n        return true;\n      }\n    } catch (error) {\n      console.error('Login error:', error);\n      \n      // Enhanced error logging\n      if (error.response) {\n        console.error('Error response data:', error.response.data);\n        console.error('Error response status:', error.response.status);\n        console.error('Error response headers:', error.response.headers);\n        setError(error.response.data.message || 'Login failed');\n      } else if (error.request) {\n        console.error('Error request:', error.request);\n        setError('No response received from server. Please try again later.');\n      } else {\n        console.error('Error message:', error.message);\n        setError(error.message || 'Login failed');\n      }\n      \n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Logout user\n  const logout = () => {\n    handleLogout();\n    navigate('/login');\n  };\n\n  // Check if user has active subscription\n  const checkSubscription = async () => {\n    if (!isAuthenticated) {\n      console.log('Not authenticated, cannot check subscription');\n      return false;\n    }\n    \n    // Add a retry mechanism for reliability\n    let retries = 2;\n    let success = false;\n    let finalResponse = null;\n    \n    while (retries >= 0 && !success) {\n      try {\n        console.log(`Checking subscription (${2-retries}/2 attempt)`);\n        const response = await checkSubscriptionApi();\n        success = true;\n        finalResponse = response;\n        console.log('Subscription check successful:', response.data);\n      } catch (error) {\n        console.error(`Attempt ${2-retries}/2 failed:`, error);\n        retries--;\n        if (retries >= 0) {\n          // Wait before retrying (500ms, then 1000ms)\n          await new Promise(resolve => setTimeout(resolve, 500 * (3 - retries)));\n        }\n      }\n    }\n    \n    if (!success || !finalResponse) {\n      console.error('All subscription check attempts failed');\n      \n      // Try to use cached data if available\n      const cachedSubscription = localStorage.getItem('vortextv_subscription_data');\n      if (cachedSubscription) {\n        try {\n          const parsedData = JSON.parse(cachedSubscription);\n          console.log('Using cached subscription data:', parsedData);\n          \n          // Update user with cached data\n          setUser(prevUser => ({\n            ...prevUser,\n            hasSubscription: parsedData.hasSubscription,\n            hasAccessCode: parsedData.hasAccessCode,\n            subscription: parsedData.subscription,\n            subscriptionPlan: parsedData.subscriptionPlan,\n            subscriptionStatus: parsedData.status,\n            subscriptionExpiry: parsedData.expiryDate,\n            generatedCodes: parsedData.generatedCodes || 0,\n            maxAllowedCodes: parsedData.maxAllowedCodes || 0,\n            remainingCodes: parsedData.remainingCodes || 0,\n            accessCodeDetails: parsedData.accessCodeDetails\n          }));\n          \n          return parsedData.hasSubscription && parsedData.status === 'active';\n        } catch (e) {\n          console.error('Error parsing cached subscription data:', e);\n        }\n      }\n      \n      return false;\n    }\n    \n    const data = finalResponse.data;\n    \n    // Cache the subscription data for later use if needed\n    localStorage.setItem('vortextv_subscription_data', JSON.stringify(data));\n    \n    // Update user data with subscription info\n    setUser(prevUser => ({\n      ...prevUser,\n      hasSubscription: data.hasSubscription,\n      hasAccessCode: data.hasAccessCode,\n      subscription: data.subscription,\n      // Add more detailed subscription data\n      subscriptionPlan: data.subscriptionPlan,\n      subscriptionStatus: data.status,\n      subscriptionExpiry: data.expiryDate,\n      generatedCodes: data.generatedCodes || 0,\n      maxAllowedCodes: data.maxAllowedCodes || 0,\n      remainingCodes: data.remainingCodes || 0,\n      accessCodeDetails: data.accessCodeDetails\n    }));\n    \n    // Check if subscription is active (not expired)\n    const isActive = data.hasSubscription && \n                    data.status === 'active' && \n                    new Date(data.expiryDate) > new Date();\n    \n    // Or check if access code is valid\n    const hasValidCode = data.hasAccessCode &&\n                        data.accessCodeDetails &&\n                        new Date(data.accessCodeDetails.expiryDate) > new Date();\n    \n    const result = isActive || hasValidCode;\n    console.log(`Subscription check result: ${result ? 'Active' : 'Inactive'}`);\n    return result;\n  };\n\n  // Generate an access code for the user's subscription\n  const generateAccessCode = async () => {\n    setIsLoading(true);\n    console.log('AuthContext: Starting access code generation');\n    \n    // Make sure subscription data is up-to-date before generating\n    try {\n      if (!isAuthenticated) {\n        console.error('AuthContext: Cannot generate code - not authenticated');\n        setError('Authentication required');\n        return {\n          success: false,\n          error: 'Authentication required'\n        };\n      }\n\n      // Check subscription status directly from user object\n      if (!user) {\n        console.error('AuthContext: Cannot generate code - no user data');\n        setError('User data unavailable');\n        return {\n          success: false,\n          error: 'User data unavailable'\n        };\n      }\n      \n      if (!user.hasSubscription) {\n        console.error('AuthContext: Cannot generate code - no active subscription');\n        setError('No active subscription found');\n        return {\n          success: false,\n          error: 'No active subscription found'\n        };\n      }\n\n      // Debug the request before sending\n      console.log('AuthContext: Making API call to generate access code');\n      \n      // Make the API request with specific headers and timeout\n      const response = await generateAccessCodeApi();\n      console.log('AuthContext: Access code API response:', response.data);\n\n      if (response.data && response.data.success) {\n        const successMsg = `Access code generated: ${response.data.code}`;\n        console.log('AuthContext: ' + successMsg);\n        setSuccess(successMsg);\n        \n        // Update subscription data in user context\n        setUser(prevUser => ({\n          ...prevUser,\n          remainingCodes: response.data.remainingCodes,\n          generatedCodes: response.data.generatedCodes\n        }));\n        \n        // Return the generated code data\n        return response.data;\n      } else {\n        const errorMsg = response.data?.error || 'Failed to generate access code';\n        console.error('AuthContext: Access code generation failed:', errorMsg);\n        setError(errorMsg);\n        return {\n          success: false,\n          error: errorMsg\n        };\n      }\n    } catch (err) {\n      console.error('AuthContext: Error generating access code:', err);\n      const errorMsg = err.response?.data?.error || err.message || 'Failed to generate access code';\n      setError(errorMsg);\n      return {\n        success: false,\n        error: errorMsg,\n        details: err.toString()\n      };\n\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Redeem an access code\n  const redeemAccessCode = async (code) => {\n    setIsLoading(true);\n    try {\n      if (!isAuthenticated) {\n        setError('Authentication required');\n        return false;\n      }\n\n      const response = await redeemAccessCodeApi(code);\n\n      if (response.data && response.data.success) {\n        setSuccess('Access code redeemed successfully');\n        // Update user's subscription status after redemption\n        await checkSubscription();\n        return response.data.accessCodeDetails;\n      } else {\n        setError(response.data.error || 'Failed to redeem access code');\n        return null;\n      }\n    } catch (err) {\n      console.error('Error redeeming access code:', err);\n      setError(err.response?.data?.error || 'Failed to redeem access code');\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const getUserAccessCodes = async () => {\n    // Guard clause - check if authenticated and has subscription\n    if (!isAuthenticated) {\n      console.log('Not authenticated, cannot get access codes');\n      return { success: false, codes: [], error: 'Authentication required' };\n    }\n    \n    if (!user || !user.hasSubscription) {\n      console.log('User has no subscription, cannot get access codes');\n      return { success: false, codes: [], error: 'No active subscription' };\n    }\n    \n    try {\n      console.log('Fetching access codes from API');\n      const response = await getAccessCodesApi();\n      \n      // Validate the response structure\n      if (response && response.data) {\n        // Check if codes array exists, if not default to empty array\n        const codes = Array.isArray(response.data.codes) ? response.data.codes : \n                     (Array.isArray(response.data) ? response.data : []);\n        \n        console.log(`Retrieved ${codes.length} access codes`);\n        return { success: true, codes: codes };\n      } else {\n        console.error('Invalid response format from access codes API');\n        return { success: false, codes: [], error: 'Invalid response format' };\n      }\n    } catch (error) {\n      console.error('Error fetching access codes:', error);\n      return { \n        success: false, \n        codes: [], \n        error: error.response?.data?.message || error.message || 'Error fetching access codes'\n      };\n    }\n  };\n\n  return (\n    <AuthContext.Provider\n      value={{\n        user,\n        isAuthenticated,\n        isLoading,\n        error,\n        success,\n        register,\n        login,\n        logout,\n        checkSubscription,\n        generateAccessCode,\n        redeemAccessCode,\n        getUserAccessCodes,\n        refreshAuth: checkUserLoggedIn // Expose this to allow manual refresh\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  );\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}